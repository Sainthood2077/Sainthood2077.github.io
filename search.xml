<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++学习之旅</title>
      <link href="/2023/01/05/c-xue-xi-zhi-lu/"/>
      <url>/2023/01/05/c-xue-xi-zhi-lu/</url>
      
        <content type="html"><![CDATA[<p>记录一下自己的C++学习内容，持续更新ing~</p><h2 id="一、初识C"><a href="#一、初识C" class="headerlink" title="一、初识C++"></a>一、初识C++</h2><h6 id="注释、变量、常量"><a href="#注释、变量、常量" class="headerlink" title="注释、变量、常量"></a>注释、变量、常量</h6><pre class=" language-c++"><code class="language-c++">//头文件#include <iostream>//声明命名空间using namespace std;/*main是一个程序的入口，有且仅有一个*///常量  1、#define宏常量  2、const修饰变量#define Day = 7;int main(){    //输出    cout << "hello world!" << endl;        //变量，方便管理内存空间    //数据类型 变量名 = 初始值    int a = 10;        //用const修饰变量也是常量    const int month = 12;            //保持命令行窗口    system("pause");    return 0;}</code></pre><h3 id="1、C-中的关键字"><a href="#1、C-中的关键字" class="headerlink" title="1、C++中的关键字"></a>1、C++中的关键字</h3><p><img src="https://gitee.com/sainthood2077/cloudimg/raw/main/images/image-20221230195657232.png" alt="image-20221230195657232"></p><h3 id="2、标识符（变量、常量）命名规则"><a href="#2、标识符（变量、常量）命名规则" class="headerlink" title="2、标识符（变量、常量）命名规则"></a>2、标识符（变量、常量）命名规则</h3><ul><li>标识符不能是关键字</li><li>标识符只能由字母数字下划线组成</li><li>第一个字符必须为字母或下划线</li><li>标识符中区分大小写</li></ul><h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h2><h3 id="1、整形"><a href="#1、整形" class="headerlink" title="1、整形"></a>1、整形</h3><table><thead><tr><th>数据类型</th><th>占用空间</th></tr></thead><tbody><tr><td>short（短整型）</td><td>2字节</td></tr><tr><td>int（整形）</td><td>4字节</td></tr><tr><td>long（长整型）</td><td>win4字节linux4字节（32位）8字节（64位）</td></tr><tr><td>long long（长长整形）</td><td>8字节</td></tr></tbody></table><h3 id="2、sizeof-关键字"><a href="#2、sizeof-关键字" class="headerlink" title="2、sizeof()关键字"></a>2、sizeof()关键字</h3><pre class=" language-c++"><code class="language-c++">int a = 10;cout << sizeof(a) << endl;//打印对象所占内存空间字节数</code></pre><h3 id="3、实型（浮点型）"><a href="#3、实型（浮点型）" class="headerlink" title="3、实型（浮点型）"></a>3、实型（浮点型）</h3><table><thead><tr><th>数据类型</th><th>占用空间</th><th>有效数字范围（统计小数点前后的）</th></tr></thead><tbody><tr><td>float</td><td>4字节</td><td>7位</td></tr><tr><td>double</td><td>8字节</td><td>15~16位</td></tr></tbody></table><p>默认情况下输出一个小数会显示出6位有效数字，要增加需要特殊配置</p><h6 id="科学计数法"><a href="#科学计数法" class="headerlink" title="科学计数法"></a>科学计数法</h6><pre class=" language-c++"><code class="language-c++">float f1 = 3e2;// 3*10^2结果为300float f2 = 3e-2;// 3*0.1^2结果为0.03</code></pre><h3 id="4、字符型"><a href="#4、字符型" class="headerlink" title="4、字符型"></a>4、字符型</h3><ul><li>C和C++中字符型变量只占用==<strong>1个字节</strong>==</li><li>字符在内存中存放的是对应的ASCII编码</li><li>创建字符变量要用==<strong>单引号</strong>==</li><li>字符型变量<strong>单引号</strong>内只能放==<strong>一个字符（单个字母）</strong>==</li></ul><pre class=" language-c++"><code class="language-c++">//查看ASCII码char ch = 'a';cout << (int)ch << endl;//输出97//也可以用ASCII给字符变量赋值char cha =  65;cout << cha << endl;</code></pre><h3 id="5、转义字符"><a href="#5、转义字符" class="headerlink" title="5、转义字符"></a>5、转义字符</h3><p>常用的转义字符<code>\n   \\   \t</code></p><p>\n  换行，将位置移到下一行开头</p><p>\\   代表一个反斜线字符<code>\</code> </p><p>\t  水平制表（跳到下一个TAB位置）可以整齐的输出后面的内容，占8个字符</p><pre class=" language-c++"><code class="language-c++">    cout << "abcdefg\t前面最多8个字符" << endl;    cout << "ab\t前面最多8个字符" << endl;    cout << "abc\t前面最多8个字符" << endl;    cout << "abcde\t前面最多8个字符" << endl;//如果满了会重新开辟8个位置    cout << "abcdefgh\t前面最多8个字符" << endl;//结果:    //abcdefg 前面最多8个字符    //ab      前面最多8个字符    //abc     前面最多8个字符    //abcde   前面最多8个字符    //abcdefgh        前面最多8个字符</code></pre><h3 id="6、字符串型"><a href="#6、字符串型" class="headerlink" title="6、字符串型"></a>6、字符串型</h3><p>1、C风格字符串<code>char 变量名[] = ”字符串值“  </code></p><p>2、C++风格字符串<code>string 变量名 = “字符串值”</code></p><ul><li>使用string类型字符串，要加入#include  &lt;string&gt;头文件</li></ul><h3 id="7、布尔类型"><a href="#7、布尔类型" class="headerlink" title="7、布尔类型"></a>7、布尔类型</h3><p>bool类型占用<code>1个字节</code></p><pre class=" language-c++"><code class="language-c++">bool flag = true; //  1flag = false; // 0</code></pre><h3 id="8、字符输入"><a href="#8、字符输入" class="headerlink" title="8、字符输入"></a>8、字符输入</h3><p>cin &gt;&gt; 变量</p><h2 id="三、运算符"><a href="#三、运算符" class="headerlink" title="三、运算符"></a>三、运算符</h2><p>算数运算符、赋值运算符、比较运算符、逻辑运算符</p><h3 id="1、算术运算符"><a href="#1、算术运算符" class="headerlink" title="1、算术运算符"></a>1、算术运算符</h3><ul><li><p><code>/</code>      除   1、除数不能为0   2、整型相除不会保留小数部分</p></li><li><p><code>%</code>     取余    1、除数为0不能做取模  2、两个小数不能做取余</p></li><li><p><code>++/--</code>   先自加再计算表达式    a=2；b=++a；   a=3；b=3；</p></li><li><p><code>++/--</code>   先计算表达式再自加    a=2；b=a++；   a=3；b=2；</p></li></ul><h3 id="2、赋值运算符"><a href="#2、赋值运算符" class="headerlink" title="2、赋值运算符"></a>2、赋值运算符</h3><ul><li>a+=2；就等价于a=a+2；</li><li>a%=2；就等价于a=a%2；</li></ul><p>同理+-*/</p><h3 id="3、比较运算符"><a href="#3、比较运算符" class="headerlink" title="3、比较运算符"></a>3、比较运算符</h3><p>相等：        ==</p><p>不相等：     !=</p><p>大于&gt;  小于&lt;  大于等于&gt;=    小于等于&lt;=</p><h3 id="4、逻辑运算符"><a href="#4、逻辑运算符" class="headerlink" title="4、逻辑运算符"></a>4、逻辑运算符</h3><p>！非</p><p>&amp;&amp;与</p><p>||或</p><h3 id="5、程序流程结构"><a href="#5、程序流程结构" class="headerlink" title="5、程序流程结构"></a>5、程序流程结构</h3><p>C/C++三种运行结构：顺序结构、选择结构、循环结构</p><h4 id="1、三目运算符"><a href="#1、三目运算符" class="headerlink" title="1、三目运算符"></a>1、三目运算符</h4><p><code>表达式1 ？表达式2 ：表达式3</code></p><p>等价于：</p><p>if 表达式1</p><p>{表达式2}</p><p>else {表达式3}</p><h4 id="2、switch语句"><a href="#2、switch语句" class="headerlink" title="2、switch语句"></a>2、switch语句</h4><pre class=" language-c++"><code class="language-c++">switch (整型或者字符型)//不能像if一样判断一个区间    {    case 结果1:表达式; break;    case 结果2:表达式; break;    case 结果3:表达式; break;    //...    default:表达式; break;    }</code></pre><p>while(…){…}</p><p>do{…}while(…);</p><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <math.h>using namespace std;int main(){    int num = 100;    do{        //三位数内的所有水仙花数        int a= 0;        int b= 0;        int c= 0;        a = num %10;//获取个位        b = num / 10 % 10;//获取十位        c = num / 100;//获取百位        int res = pow(a,3)+pow(b,3)+pow(c,3);        if(num == res){//判断是水仙花数才输出            cout << "水仙花数有：" << num <<endl;        }        num++;            }    while (num < 1000);    system("pause");    return 0;}</code></pre><p>for(起始表达式；条件表达式；末尾循环体){…}</p><pre class=" language-c++"><code class="language-c++">for (int i= 1;i<10;i++){ //输出九九乘法表               for (int j = 1;j<=i;j++){            cout << j << "*" << i << "=" << i*j << "\t";        }        cout << " " << endl;    }</code></pre><h4 id="3、跳转语句"><a href="#3、跳转语句" class="headerlink" title="3、跳转语句"></a>3、跳转语句</h4><p>break；continue；goto；</p><pre class=" language-c++"><code class="language-c++">//代码...，会执行goto FLAG;//在程序中不建议使用goto，了解即可，会导致程序混乱//代码...中间的都不会执行FLAG：//代码...会执行</code></pre><h2 id="四、数组"><a href="#四、数组" class="headerlink" title="四、数组"></a>四、数组</h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><ul><li>数组内的元素都是<strong>相同的数据类型</strong></li><li>数组由<strong>连续的内存位置</strong>组成</li></ul><h3 id="2、一维数组"><a href="#2、一维数组" class="headerlink" title="2、一维数组"></a>2、一维数组</h3><p>定于数组：</p><p>1.<code>数据类型 数组名[数组长度]；</code></p><p>2.<code>数据类型 数组名[ 数组长度 ] = {值1，值2....}</code></p><p>3.<code>数据类型 数组名[  ] = { 值1，值2...}</code></p><ul><li>定义数组时必须要有初始长度</li><li>数组中没有被定义的位置，为0</li><li>数组下标从0开始索引</li></ul><pre class=" language-c++"><code class="language-c++">int arr[] = {8,9};cout << (int)arr << endl;//arr的首地址cout << (int)&arr[0] << endl;//arr第一个元素的地址</code></pre><pre class=" language-c++"><code class="language-c++">int arr[] = {8,0,1,9,3,6,5,123,122,45,22,4};//冒泡排序，任意数组大小都可以排序    for (int i=0;i<sizeof(arr)/sizeof(arr[0])-1;i++){        for (int j= 0; j<sizeof(arr)/sizeof(arr[0])-1-i;j++){            if (arr[j]>arr[j+1]){            int tmp = arr[j];            arr[j] = arr[j+1];            arr[j+1] = tmp;        }        }         continue;    }    for (int item =0 ;item<sizeof(arr)/sizeof(arr[0]);item++){        cout << arr[item] << " ";        cout << endl;    }</code></pre><h3 id="3、二维数组"><a href="#3、二维数组" class="headerlink" title="3、二维数组"></a>3、二维数组</h3><p>定义方式：</p><p>1.<code>数据类型 数组名[ 行数 ][ 列数 ]；</code></p><p>2.<code>数据类型 数组名[ 行数 ][ 列数 ] = {{数据1，数据2}，{数据3，数据4}}；</code><strong>建议使用第二种</strong>，更加直观</p><p>3.<code>数据类型 数组名[ 行数 ][ 列数 ] = {数据1，数据2，数据3，数据4}；</code></p><p>4.<code>数据类型 数组名[  ][ 列数 ] = {数据1，数据2，数据3，数据4}；</code></p><pre class=" language-c++"><code class="language-c++">int arr[3][4] = {{1,2,3},{4,5,6}};cout << sizeof(arr) << endl;//二维数组占用的内存空间48cout << sizeof(arr[0][0]) << endl;//二维数组第一个元素占用的内存空间4cout << (long long)arr << endl;//二维数组内存首地址cout << (long long)&arr[0] << endl;//二维数组第一行的首地址cout << (long long)&arr[0][0] << endl;//二维数组第一个元素的地址cout << sizeof(arr)/sizeof(arr[0]) << endl;//获取二维数组的行数cout << sizeof(arr[0])/sizeof(arr[0][0]) << endl;//获取二维数组列数</code></pre><h2 id="五、函数"><a href="#五、函数" class="headerlink" title="五、函数"></a>五、函数</h2><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><pre><code>返回值类型  函数名(参数列表){    函数体语句    return 表达式；}</code></pre><h3 id="2、值传递"><a href="#2、值传递" class="headerlink" title="2、值传递"></a>2、值传递</h3><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;void swap(int num1,int num2){    int tmp = num1;    num1 = num2;    num2 = tmp;    return;}int main(){    int a= 2;    int b= 3;    swap(a,b);    cout << a << " " << b << endl;//结果依旧是2 3    //在值传递的时候，函数体内的形参的变化，不会影响实参       system("pause");    return 0;}</code></pre><h3 id="3、函数样式"><a href="#3、函数样式" class="headerlink" title="3、函数样式"></a>3、函数样式</h3><ul><li>无参无返</li><li>有参无返</li><li>无参有返</li><li>有参有返</li></ul><h3 id="4、函数声明"><a href="#4、函数声明" class="headerlink" title="4、函数声明"></a>4、函数声明</h3><p><code>函数类型  函数名（形参列表）；</code>此时函数可以写在最后</p><p>声明可以写多次，但是函数定义只能有一次</p><h3 id="5、函数分文件编写"><a href="#5、函数分文件编写" class="headerlink" title="5、函数分文件编写"></a>5、函数分文件编写</h3><p>1、创建.h的头文件</p><p>2、创建.cpp的源文件</p><p>3、在头文件写函数声明</p><p>4、在源文件写函数定义</p><p>例：</p><p>头文件(.h)：</p><pre class=" language-c++"><code class="language-c++">#include <iostream>//记得添加系统头文件using namespace std;void swap(int num1,int num2)；//函数声明</code></pre><p>源文件(.cpp)：</p><pre class=" language-c++"><code class="language-c++">//记得引用写好函数声明的头文件#include "cpp_obj.h"//注意自己写的头文件要用双引号void swap(int num1,int num2){    int tmp = num2;    num2 = num1;    num1 = tmp;    cout << "num1 =" << num1 << endl;    cout << "num2 =" << num2 << endl;}</code></pre><p>使用函数的主文件：</p><pre class=" language-c++"><code class="language-c++">#include "cpp_obj.h"//需要添加头文件使用</code></pre><h2 id="六、指针"><a href="#六、指针" class="headerlink" title="六、指针"></a>六、指针</h2><p><strong>指针就是一个地址</strong></p><p>定义：<code>数据类型 * 指针变量名；</code></p><p>使用：</p><pre class=" language-c++"><code class="language-c++">//可以通过解引用（在指针前加 * ）的方式找到指针指向的内存*p = 2;cout << a << endl; //结果为2，数据被修改cout << *p << endl;  //结果为2</code></pre><p>内存地址：</p><p>32位（无论什么类型）指针变量内存地址为4位；</p><p>32位（无论什么类型）指针变量内存地址为8位；</p><h3 id="1、空指针"><a href="#1、空指针" class="headerlink" title="1、空指针"></a>1、空指针</h3><pre class=" language-c++"><code class="language-c++">int* p = NULL;</code></pre><ul><li>空指针用于给指针初始化</li><li>内存编号0~255为系统占用，空指针是不可以被访问的</li></ul><h3 id="2、野指针"><a href="#2、野指针" class="headerlink" title="2、野指针"></a>2、野指针</h3><pre class=" language-c++"><code class="language-c++">int* p = （int* ）0x1100；//指针变量p指向内存编号为0x1100的空间cout << *p << endl;//访问野指针会报错，0x1100内存并没有申请，没有访问权限，尽量避免出现野指针</code></pre><p><strong>空指针、野指针都不是我们申请的空间，因此请不要访问</strong></p><h3 id="3、const修饰指针"><a href="#3、const修饰指针" class="headerlink" title="3、const修饰指针"></a>3、const修饰指针</h3><h4 id="1-const修饰指针——常量指针"><a href="#1-const修饰指针——常量指针" class="headerlink" title="1.const修饰指针——常量指针"></a>1.const修饰指针——常量指针</h4><pre class=" language-c++"><code class="language-c++">int a = 3;const int * p = &a;//p就是一个常量指针*p = 66;//不能更改p = &b;//可以更改</code></pre><blockquote><p> 指针的<strong>指向可以修改</strong>，但指针指向的<strong>值不可以修改</strong>；想要修改指针的指向，指向新的地址的内存必须和之前的值一致</p></blockquote><h4 id="2-const修饰常量——指针常量"><a href="#2-const修饰常量——指针常量" class="headerlink" title="2.const修饰常量——指针常量"></a>2.const修饰常量——指针常量</h4><pre class=" language-c++"><code class="language-c++">int a = 3;int * const p = &a;*p = 66;//可以更改p = &b;//不能更改</code></pre><blockquote><p>指针的<strong>指向<u>不能</u>更改</strong>，但是指针的<strong>值可以更改</strong></p></blockquote><h4 id="3-const既修饰指针，也修饰变量"><a href="#3-const既修饰指针，也修饰变量" class="headerlink" title="3.const既修饰指针，也修饰变量"></a>3.const既修饰指针，也修饰变量</h4><blockquote><p>指针的<strong>指向</strong>和指针<strong>指向的值</strong>都不能修改 </p></blockquote><h4 id="4-指针和数组"><a href="#4-指针和数组" class="headerlink" title="4.指针和数组"></a>4.指针和数组</h4><p>用指针访问数组中的元素</p><pre class=" language-c++"><code class="language-c++">int a[4] = {1,2,3,4};int * p = a;cout << *p << endl;//结果为1p++;cout << *p << endl;//结果为2cout << p[2] << endl; // 结果为3p++;cout << p[2] << endl; // 结果为4for (int i=0;i < 4;i++){//用指针遍历数组        cout << *p << endl;        p++;    }</code></pre><h4 id="5-指针和函数"><a href="#5-指针和函数" class="headerlink" title="5.指针和函数"></a>5.指针和函数</h4><p>函数定义的形参用指针代替，传入的值是实参的地址，实参内存地址被改变，值相应改变</p><p>通过<strong>指针代替形参传递，可以改变实参的值</strong></p><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;void bubble(int *arr, int len) // 如何传递数组：将首地址传进来{    for (int i = 0; i < 10 - 1; i++)    {        for (int j = 0; j < 10 - 1 - i; j++)        {            if (arr[j] > arr[j + 1])            {                int tmp = arr[j];                arr[j] = arr[j + 1];                arr[j + 1] = tmp;            }        }    }}int main(){    // 封装一个函数，实现对一个数组的冒泡排序    int array1[10] = {7, 2, 4, 5, 8, 10, 9, 6, 3, 1};    int len = sizeof(array1) / sizeof(array1[0]);    bubble(array1, len);    int *p_array1 = array1;    for (int i = 0; i < len; i++)    {        cout << *p_array1 << endl;        p_array1++;    }    system("pause");    return 0;}</code></pre><h2 id="七、结构体"><a href="#七、结构体" class="headerlink" title="七、结构体"></a>七、结构体</h2><p>定义：<code>struct 结构体名 { 结构体成员列表 }；</code></p><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <string>using namespace std;struct Stu{//结构体变量定义的时候不能省略    string name ;    int age;    int score;};int main(){    struct Stu s1;    s1.age = 12;    s1.name = "张三";    s1.score = 100;    cout << s1.name << s1.age << s1.score << endl;    Stu s2{ "李四", 19 , 99 };//结构体变量创建的时候可以省略    cout << s2.name << s2.age << s2.score << endl;    system("pause");    return 0;}</code></pre><h3 id="1、结构体数组"><a href="#1、结构体数组" class="headerlink" title="1、结构体数组"></a>1、结构体数组</h3><p><code>struct 结构体名 数组名[元素个数] = {  { }，{ }，{ }, . .   }</code></p><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <string>using namespace std;struct Stu{//定义结构体    string name ;    int age;    int score;};int main(){    struct Stu arr[3]=    {        { "李四", 19 , 99 },        { "张三", 13 , 100 },        { "李逵", 15 , 96 },    };    //使用结构体数组    cout << arr[1].name << arr[1].age << arr[1].score << endl;    system("pause");    return 0;}</code></pre><h3 id="2、结构体指针"><a href="#2、结构体指针" class="headerlink" title="2、结构体指针"></a>2、结构体指针</h3><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <string>using namespace std;struct Stu{ // 定义结构体    string name;    int age;    int score;};int main(){    Stu stu1 = {"李逵", 15, 96}; // 创建结构体变量    Stu *p = &stu1;              // 指针指向结构体变量    p->age = 0;//结构体指针可以改变指向的内存    cout << p->name << p->age << p->score << endl;//使用结构体指针    system("pause");    return 0;}</code></pre><h3 id="3、结构体嵌套结构体"><a href="#3、结构体嵌套结构体" class="headerlink" title="3、结构体嵌套结构体"></a>3、结构体嵌套结构体</h3><p>在结构体中可以定义另一个结构体作为成员，以便使用</p><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <string>using namespace std;struct Info//嵌套的结构体{    int grade;   // 年级    int classes; // 班级    long long stu_num;//学号};struct Stu{ // 定义结构体    string name;    int age;    int score;    struct Info stu1_info; // 学生的信息，需要提前定义};int main(){    Stu stu1 = {"李逵", 15, 96, 19, 1, 201902250101}; // 创建结构体变量    Stu *p = &stu1;                                   // 指针指向结构体变量                                    // 结构体指针可以改变指向的内存    cout << "学生姓名：" << p->name << endl;    cout << "学生年龄：" << p->age << endl;    cout << "学生成绩：" << p->score << endl;    cout << "学生年级：" << p->stu1_info.grade << endl;    cout << "学生班级：" << p->stu1_info.classes << endl;    cout << "学生学号：" << p->stu1_info.stu_num << endl; // 使用结构体指针    system("pause");    return 0;}</code></pre><h3 id="4、结构体做函数参数"><a href="#4、结构体做函数参数" class="headerlink" title="4、结构体做函数参数"></a>4、结构体做函数参数</h3><p><code>值传递</code>和<code>地址传递</code></p><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <string>using namespace std;struct Stu{ // 定义结构体    string name;    int age;    int score;};void PrintfStu(struct Stu stu1){//值传递    cout << "****打印学生信息(值传递版)****" << endl;    cout << "学生姓名：" << stu1.name << endl;    cout << "学生年龄：" << stu1.age << endl;    cout << "学生成绩：" << stu1.score << endl;}int main(){    Stu stu1 = {"李逵", 15, 96}; // 创建结构体变量    PrintfStu(stu1);    system("pause");    return 0;}</code></pre><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <string>using namespace std;struct Stu{ // 定义结构体    string name;    int age;    int score;};void PrintfStu(struct Stu * p){//用指针接收地址    cout << "****打印学生信息(指针版)****" << endl;    cout << "学生姓名：" << p->name << endl;    cout << "学生年龄：" << p->age << endl;    cout << "学生成绩：" << p->score << endl;    //函数体内部改变，可以改变实参的值    //列：p->age = 19；则函数外部访问stu1.age结构为19}int main(){    Stu stu1 = {"李逵", 15, 96}; // 创建结构体变量    //PrintfStu(stu1);//值传递    PrintfStu(&stu1);//地址传递    system("pause");    return 0;}</code></pre><h3 id="5、结构体中const的使用场景"><a href="#5、结构体中const的使用场景" class="headerlink" title="5、结构体中const的使用场景"></a>5、结构体中const的使用场景</h3><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <string>using namespace std;struct Stu{ // 定义结构体    string name;    int age;    int score;};void PrintfStu(const Stu * p){//用const修饰，限制指针的修改，防止函数体中误操作    cout << "****打印学生信息(指针版)****" << endl;    cout << "学生姓名：" << p->name << endl;    cout << "学生年龄：" << p->age << endl;    cout << "学生成绩：" << p->score << endl;    //p->age=100; 操作失败，因为加了const修饰}int main(){    Stu stu1 = {"李逵", 15, 96}; // 创建结构体变量    PrintfStu(&stu1);    system("pause");    return 0;}</code></pre><h3 id="6、案例：结构体数组冒泡排序"><a href="#6、案例：结构体数组冒泡排序" class="headerlink" title="6、案例：结构体数组冒泡排序"></a>6、案例：结构体数组冒泡排序</h3><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <string>using namespace std;struct Hero{    string name;    int age;    string gender;};void Bubble_Hero(struct Hero hero_arr[5],int len){//冒泡排序函数    for (int i = 0; i < len - 1; i++)    {        for (int j = 0; j < len - 1 - i; j++)        {            if (hero_arr[j].age > hero_arr[j + 1].age)            {                Hero tmp = hero_arr[j];                hero_arr[j] = hero_arr[j + 1];                hero_arr[j + 1] = tmp;            }        }    }}void PrintHero(Hero *hero_p,int len)//打印函数{    for (int item = 0; item < len; item++)    {        cout << "年龄：" << hero_p->age << " "             << "英雄：" << hero_p->name << endl;        hero_p++;    }}int main(){    Hero hero_arr[5] = {        {"刘备", 23, "男"},        {"关于", 22, "男"},        {"赵云", 20, "男"},        {"张飞", 21, "男"},        {"貂蝉", 19, "女"},    };    int len = sizeof(hero_arr) / sizeof(hero_arr[0]);        Bubble_Hero(hero_arr,len);//利用冒泡排序，将结构体数组排序打印    PrintHero(hero_arr,len);    system("pause");    return 0;}</code></pre><h2 id="八、面向对象"><a href="#八、面向对象" class="headerlink" title="八、面向对象"></a>八、面向对象</h2><h3 id="1、内存分区模型"><a href="#1、内存分区模型" class="headerlink" title="1、内存分区模型"></a>1、内存分区模型</h3><ul><li>代码区：存放二进制代码，由操作系统管理</li><li>全局区：存放全局变量和静态变量以及常量</li><li>栈区：由编译器自动分配释放，存放函数的<strong>参数值，局部变量（在函数体内）等</strong></li><li>堆区：由程序员分配和释放，若程序员不是放，程序结束时由操作系统回收</li></ul><blockquote><p>意义：不用区域存放的数据，赋予不同的生命周期，给我们更大的灵活变成</p></blockquote><h4 id="1-1程序运行前"><a href="#1-1程序运行前" class="headerlink" title="1.1程序运行前"></a>1.1程序运行前</h4><p>在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域</p><p><strong>代码区：</strong></p><p>存放CPU执行的机器指令（二进制）</p><p>代码区具<strong>共享</strong>的：共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p><p>代码区是<strong>只读</strong>的：使其只读的原因是防止程序意外地修改了它的指令</p><p><strong>全局区：</strong></p><p><u>全局变量</u>和<u>静态变量</u>（static）存放在此 </p><p>全局区还包含了<u>常量区</u>，<u>字符串常量</u>和<u>const修饰的全局常量</u>也存放在此，该区域的数据在程序结束后由操作系统释放</p><pre class=" language-c++"><code class="language-c++">int b = 12;//在函数体外就是全局变量const int g_b = 12;//全局常量int main()//主函数{    int a = 12;//在函数体内，是局部变量    cout << "a(局部变量)的内存地址是:" << (long long)&a << endl;//a(局部变量)的内存地址是6487580    const int l_a = 12;    cout << "l_a(局部常量)的内存地址是:" << (long long)&l_a << endl;//l_a(局部常量)的内存地址是:6487576        cout << "b(局部变量)的内存地址是:" << (long long)&b << endl;//b(全局变量)的内存地址是4206608    cout << "g_b(全局常量)的内存地址是:" << (long long)&g_b << endl;//g_b(全局常量)的内存地址是:4210688    static int c = 12;    cout << "c(静态变量)的内存地址是:" << (long long)&c << endl;//c(静态变量)的内存地址是:4206612    //常量，字符串都称为字符串常量    cout << "字符串常量的内存地址是:" << (long long)&"字符串" << endl;//字符串常量的内存地址是:4210787            system("pause");    return 0;}</code></pre><h4 id="1-2程序运行后"><a href="#1-2程序运行后" class="headerlink" title="1.2程序运行后"></a>1.2程序运行后</h4><p><strong>栈区：</strong></p><p>由编译器自动分配释放，存放函数的参数值，局部变量等</p><blockquote><p>注意事项：不要返回局部变量的地址，浅区开辟的数据由编译器自动释放</p></blockquote><p><strong>堆区：</strong></p><p>由程序员分配释放，若程序员不释放程序结束时由操作系统回收</p><p>在C++中主要利用new在堆区开辟内存</p><h4 id="1-3new操作符"><a href="#1-3new操作符" class="headerlink" title="1.3new操作符"></a>1.3new操作符</h4><p>C++中利用<strong>new</strong>操作符在堆区开辟数据</p><p>堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符<strong>delete</strong></p><p>语法：<code>new数据类型</code></p><blockquote><p>利用<strong>new创建的数据</strong>，会<strong>返回该数据<u>对应的类型的指针</u></strong></p></blockquote><pre class=" language-c++"><code class="language-c++">int * Func(){    int *p = new int(12);//new操作在堆区开辟了一块数据存放元素12，会返回该数据类型的指针    //int *p = new int[11];//还可以new一个数组，返回的是数组的首地址    return p;//返回指针地址}int main(){    int * p = Func();要用指针接收    cout << *p << endl;//解析指针内存地址，输出    delete p;//释放堆内存    //cout << *p << endl;运行会报错，内存已经被释放，无法访问}</code></pre><h3 id="2、引用"><a href="#2、引用" class="headerlink" title="2、引用"></a>2、引用</h3><p>本质：给变量起别名</p><p>语法：<code>(和原来一致的)数据类型 &amp;别名 = 原名</code></p><blockquote><ul><li>修改引用也会修改原来的变量，因为操纵的是一块内存</li><li>引用必须初始化</li><li>一个变量可以有多个引用，一个引用只能指向一个实体</li></ul></blockquote><pre class=" language-c++"><code class="language-c++">int a;int & b = a;//b为a的引用//int & a_num;错误的，引用避暑初始化</code></pre><h4 id="1、将引用作为函数参数"><a href="#1、将引用作为函数参数" class="headerlink" title="1、将引用作为函数参数"></a>1、将引用作为函数参数</h4><pre class=" language-c++"><code class="language-c++">void swapv(int a,int b); // 值传递                不能改变调用函数中的值void swapr(int & a,int & b); // 引用传递        能改变调用函数中的值void swapp(int * a,int * b); // 指针传递          能改变调用函数中的值</code></pre><h4 id="2、引用做函数的返回值"><a href="#2、引用做函数的返回值" class="headerlink" title="2、引用做函数的返回值"></a>2、引用做函数的返回值</h4><h5 id="a-不要换返回局部变量的引用"><a href="#a-不要换返回局部变量的引用" class="headerlink" title="a.不要换返回局部变量的引用"></a>a.不要换返回局部变量的引用</h5><pre class=" language-c++"><code class="language-c++">int &test()//例如这个函数就是不合法的{    int a = 10;//局部变量存放在栈区，函数执行完毕就被释放    return a;}</code></pre><h5 id="b-函数的调用可以作为左值"><a href="#b-函数的调用可以作为左值" class="headerlink" title="b.函数的调用可以作为左值"></a>b.<strong>函数的调用可以作为左值</strong></h5><pre class=" language-c++"><code class="language-c++">int &test_02(){    static int a = 14;//静态变量，存放在全局区，全局区上的数据在整个程序结束由系统释放释放    return a;//返回a的引用}int main(){    int &ref_02 = test_02();//ref_02相当于引用的a    cout << ref_02 << endl;//结果为14    //无论是ref_02还是test_02都是a的引用，都可以对a的内存进行操作    test_02() = 133    out << ref_02 << endl;//结果为133    cout << test_02() << endl;//结果为133    system("pause");    return 0;}</code></pre><h4 id="3、常量引用（引用时尽可能使用const）"><a href="#3、常量引用（引用时尽可能使用const）" class="headerlink" title="3、常量引用（引用时尽可能使用const）"></a>3、常量引用（引用时尽可能使用const）</h4><blockquote><ul><li>使用const能避免无意中修改数据的编程错误</li><li>使用const能够处理const和非const实参，否则只能接受非const数据</li><li>使用const引用使函数能正确的生成并使用临时变量</li></ul></blockquote><p>作用：主要用来修饰形参，防止误操作，<u>在函数形参列表中，可以加const修饰形参，防止形参改变实参</u></p><pre class=" language-c++"><code class="language-c++">//引用使用的场景，通常用来修饰形参void showvalue(const int&v){    //y+=10;    cout << v <<endl;}int main() {    //int &ref=10;引用本身需要一个合法的内存空间，因此这行错误    //加入const就可以了，编译器优化代码，int temp=18;const int&ref=temp;    const int &ref = 10;//都相当于引用了一个临时变量    //ref=100;加入const后不可以修改变量    cout << ref <<endl;    //函数中利用常量引用防止误操作修改实参    int a =10;    showValue(a);}</code></pre><pre class=" language-c++"><code class="language-c++">// 函数声明double cube(double &a){    a = a * a;}// 调用函数cube(x+2);</code></pre><p>当函数cube()的引用参数应该是可以修改的，但是传递的值是（x+2）并不是变量，所以编译时会出现错误。</p><p>但是，如果在引用前加上const程序就能运行了，const指定引用不能被修改，所以是否为变量也就不重要了。但是编译器会为其创建一个临时变量，保存（x+2）,然后将 a 成为临时变量的引用</p><p><strong>那么什么情况下会创建临时变量呢？如果引用参数是const，则编译器会在下面两种情况生成临时变量：</strong></p><ul><li>实参的类型正确，但不为左值</li><li>实参的类型不正确，但可以转化为右值</li></ul><h4 id="4、引用的本质"><a href="#4、引用的本质" class="headerlink" title="4、引用的本质"></a>4、引用的本质</h4><p>引用的本质在c++内部实现是一个指针常量</p><pre class=" language-c++"><code class="language-c++">//自动转换为int * const ref = &a;指针常量是指针指向不可改，也说明为什么引用不可更改int &ref = a;ref=20;//内部发现ref是引用，自动帮我们转换为：*ref=20</code></pre><h4 id="5、引用总结"><a href="#5、引用总结" class="headerlink" title="5、引用总结"></a>5、引用总结</h4><p>使用引用参数的原因：</p><ol><li><p>修改调用函数中的函数对象</p></li><li><p>通过传递引用而不是整个数据对象，提高程序的运行速度</p></li></ol><p>当数据对象较大的时候，第二个原因尤为重要。这些也是使用指针参数的原因。</p><p><strong>那么指针参数和引用又有什么区别呢？</strong></p><p>引用参数实际上是基于指针的代码的另一个接口，至此，引用展现了它的庐山真面目，<u>其实它和指针在底层实现没什么两样</u>，只是在使用上，有时引用会更加顺手。</p><blockquote><p>那么什么情况下，应该使用何种传递参数的方式呢？</p><ul><li><strong>数据对象小且不做修改，例如内置类型和小型结构，按值传递。</strong></li><li><strong>数据对象数组，只能使用指针传递。</strong></li><li><strong>结构，引用和指针都可以</strong></li><li><strong>类，使用引用</strong></li></ul></blockquote><h2 id="九、函数高级"><a href="#九、函数高级" class="headerlink" title="九、函数高级"></a>九、函数高级</h2><h3 id="1、函数默认参数"><a href="#1、函数默认参数" class="headerlink" title="1、函数默认参数"></a>1、函数默认参数</h3><pre class=" language-c++"><code class="language-c++">int func(int a = 1, int b = 2, int c = 3){    return a + b + c;}int main{    func(4,5)//结果是4+5+3=12}</code></pre><p>如果函数有默认值，还没有传对应的值，那么用默认值；如果有传(对应的)值，那么优先用传值</p><blockquote><p>C++规定，默认参数只能放在形参列表的最后，而且一旦为某个形参指定了默认值，那么它后面的所有形参都必须有默认值。</p></blockquote><ul><li><p>如果函数声明有默认参数，函数实现就不能有默认参数；函数声明和函数实现智能有一个有默认参数</p></li><li><p>默认参数除了是可以是常量还可以是变量</p></li></ul><h3 id="2、函数占位参数"><a href="#2、函数占位参数" class="headerlink" title="2、函数占位参数"></a>2、函数占位参数</h3><p>语法：<code>函数类型  函数名（参数类型）</code> </p><p>目前了解，还用不到，以后会用到</p><pre class=" language-c++"><code class="language-c++">void func(int,float = 10.12);//占位参数还可以有默认参数</code></pre><h3 id="3、函数重载"><a href="#3、函数重载" class="headerlink" title="3、函数重载"></a>3、函数重载</h3><p>作用：函数名可以相同，提高复用性</p><p>函数重载满足条件：</p><ul><li>同一个作用于下（目前写的函数都是全局函数）</li><li>函数名相同</li><li>函数参数<strong>类型不同</strong>或者<strong>个数不同</strong>或者<strong>顺序不同</strong></li></ul><pre class=" language-c++"><code class="language-c++">void swap(float &a, float &b){    double tmp = a;    a = b;    b = tmp;}void swap(int &a, int &b) // 函数重载{    double tmp = a;    a = b;    b = tmp;}int main(){    int x = 12;    int y = 15;    float fx = 1.22;    float fy = 3.14;    swap(fx, fy);    swap(x, y);    cout << x << " " << y << endl;    cout << fx << " " << fy << endl;}</code></pre><p>函数的返回值不能作为函数重载的条件</p><pre class=" language-c++"><code class="language-c++">void func(float a;double b){}int func(float a;double b){}//函数的返回值不能作为函数重载的条件</code></pre><h4 id="a-引用作为重载的注意事项"><a href="#a-引用作为重载的注意事项" class="headerlink" title="a.引用作为重载的注意事项"></a>a.引用作为重载的注意事项</h4><pre class=" language-c++"><code class="language-c++">void fun(float &a, ){    cout  << "对fun（float）的调用" << endl;}void fun(const float &a) {    cout  << "对fun（const float）的调用" << endl;}int main(){    int a = 10;    fun(a);//对fun（float）的调用    fun(10);//对fun（const float）的调用,有const会在创建临时变量接收}</code></pre><h4 id="b-函数重载遇到默认参数"><a href="#b-函数重载遇到默认参数" class="headerlink" title="b.函数重载遇到默认参数"></a>b.函数重载遇到默认参数</h4><pre class=" language-c++"><code class="language-c++">void fun(float a){    cout  << "对fun（float a）的调用" << endl;}void fun(float a,int b  = 10) //有默认参数就可以忽略不看，对比剩下的参数{    cout  << "对fun（float a, int b  = 10）的调用" << endl;}int main(){    int a = 10;    fun(a);//此时对两个fun()都可以调用，会报错}</code></pre><p>当<strong>函数重载时，尽量不要使用默认参数</strong>，很容易出现二义性导致报错</p><h2 id="十、类和对象"><a href="#十、类和对象" class="headerlink" title="十、类和对象"></a>十、类和对象</h2><h3 id="1、封装"><a href="#1、封装" class="headerlink" title="1、封装"></a>1、封装</h3><h4 id="1-封装的意义"><a href="#1-封装的意义" class="headerlink" title="1.封装的意义"></a>1.封装的意义</h4><pre class=" language-c++"><code class="language-c++">const double PI = 3.14;class Cricle{public://访问权限，公共类    int r ;//属性    double cricle_grith()//行为    {        return 2 * PI * r;    }};int main(){    Cricle c_1;//创建对象    c_1.r = 3.3;//给属性赋值    cout << c_1.cricle_grith() << endl;}</code></pre><p>语法:<code>class 类名 {    访问权限：   属性  /   行为     }；</code></p><pre class=" language-c++"><code class="language-c++">class Stu{public://访问权限，公共类    string stu_name;    string stu_num;    void show_stu_info()    {        cout << stu_name << endl;        cout << stu_num << endl;    }    void setName(string name)//用成员函数给对象属性复制    {        stu_name = name;    }    void setNum(string num)//用成员函数给对象属性复制    {        stu_num = num;    }};int main(){    Stu stu_1;    //stu_1.stu_name = "小明";    //stu_1.stu_num = "201902250417";    stu_1.setName("小红");    stu_1.setNum("201902250417");    stu_1.show_stu_info();}</code></pre><p>封装权限：</p><p>1.公共权限：public                   类内可以访问，类外可以访问</p><p>2.保护权限：protected              类内可以访问，类外不可以访问，子类可以访问</p><p>3.私有权限：private                   类内可以访问，类外不可以访问，子类不可以访问</p><h4 id="2-struct和class的区别"><a href="#2-struct和class的区别" class="headerlink" title="2.struct和class的区别"></a>2.struct和class的区别</h4><p><strong>默认的访问权限不同</strong></p><ul><li>struct默认权限为公共 </li><li>class默认权限为私有</li></ul><h4 id="3、将成员属性私有化"><a href="#3、将成员属性私有化" class="headerlink" title="3、将成员属性私有化"></a>3、将成员属性私有化</h4><ul><li>将成员属性私有化，可以自己控制读写权限</li><li>对于写权限，我们可以监测数据的有效性</li></ul><pre class=" language-c++"><code class="language-c++">class Stu{public://访问权限，公共类    string getName()//可读    {        return stu_name;}    void setName(string name)//可写    {        stu_name = name;}    void setNum(string num)//只可写    {        stu_num = num;}    int getAge(int age)//只可读    {        age = 0;//设置默认值        return stu_age;}private://成员属性设置为私有类，类外部无法访问，可以用过公有化访问权限进行读写    string stu_name;//可读可写    string stu_num;//只可写    int stu_age;//只可读};</code></pre><pre class=" language-c++"><code class="language-c++">class Stu{public://访问权限，公共类    void setNum_show(string num)//可写    {        if(num.size() == 12)//可以检测数据的合法性        {            stu_num = num;            cout << "输入的学号为: " << stu_num << " 请确认" << endl;}        else        {            cout << "学号输入错误，请重新输入" << endl;}    }private:    string stu_num;//只可写};int main(){    Stu s1;    s1.setNum_show("201902250417");//输入的学号为: 201902250417 请确认    //s1.setNum_show("学号");学号输入错误，请重新输入}</code></pre><blockquote><p>注意：定义<strong>全局函数</strong>(在class外定义的)和<strong>成员函数</strong>(在class内定义的)定义时传参的不同；成员函数需要有一个对象进行调用</p><p>在类中可以让另一个类，作为本类中的成员</p></blockquote><h4 id="4、将类分文件编写"><a href="#4、将类分文件编写" class="headerlink" title="4、将类分文件编写"></a>4、将类分文件编写</h4><p>头文件（.h）：</p><pre class=" language-c++"><code class="language-c++">class Stu{public:    //声明成员函数:void setNum(string num);    //声明成员函数:void setNum_show(string num);    //...private:    //成员属性:string stu_num;    //成员属性:string stu_num;    //成员属性:string stu_num;    //...};</code></pre><p>原文件（.cpp）：</p><pre class=" language-c++"><code class="language-c++">#include "xxx.h"void Student::setNum(string num)//写函数实现，和作用域{    //...}void Teacher::setNum_show(string num){    //...}//...</code></pre><p>不加作用域会被认为是全局函数</p><h3 id="2、对象的初始化和清理"><a href="#2、对象的初始化和清理" class="headerlink" title="2、对象的初始化和清理"></a>2、对象的初始化和清理</h3><h4 id="1-构造函数和析构函数"><a href="#1-构造函数和析构函数" class="headerlink" title="1.构造函数和析构函数"></a>1.构造函数和析构函数</h4><p>C++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个函数将会被<strong>编译器自动调用</strong>，完成对象初始化和清理工作。对象的初始化和清理工作是编译器<strong>强制</strong>要我们做的事情，因此如果我们不提供构造和析构，编译器会提供<strong>编译器提供的构造函数和析构函数是空实现</strong>。</p><ul><li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li><li>析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。</li></ul><p><strong>构造函数语法：</strong><code>类名(){}</code></p><ol><li><p>构造函数，没有返回值也不写void</p></li><li><p>函数名称与类名相同</p></li><li><p>构造函数可以有参数，因此可以发生重载</p></li><li><p>程序在调用对象时候会自动调用构造，无须手动调用，而且只会调用一次</p></li></ol><p><strong>析构函数语法：</strong><code>~类名(){}</code></p><ol><li><p>析构函数，没有返回值也不写void</p></li><li><p>函数名称与类名相同，在名称前加上符号~</p></li><li><p>析构函数不可以有参数，因此不可以发生重载</p></li><li><p>程席在对象销毁前会自动调用析构.无须手动调用.而且只会调用一次</p></li></ol><h4 id="2-构造函数的分类及调用"><a href="#2-构造函数的分类及调用" class="headerlink" title="2.构造函数的分类及调用"></a>2.构造函数的分类及调用</h4><p>分为<u>无参构造</u>和<u>有参构造</u>；也可以分为<u>普通构造</u>和<u>拷贝构造</u></p><pre class=" language-c++"><code class="language-c++">class Person{public:    Person()//构造函数（默认构造函数）    {cout<< "正在执行默认构造函数" << endl;}    Person(int a)//有参构造函数    {        age = a;        cout<< "正在执行有参构造函数" << endl;}    Person(const Person &p)//拷贝构造函数    {        age = p.age;        cout<< "正在执行拷贝构造函数" << endl;}    ~Person()//析构函数    {cout<< "正在执行析构函数" << endl;}private:    int age;};void fun_p()//调用{    //1、括号法    Person p;//默认构造函数调用    Person p1(2);//有参构造函数调用    Person p2(p1);//拷贝构造函数调用    //2、显示法    Person p3 = Person(2);//有参构造函数调用    Person p4 = Person(p3);//拷贝构造函数调用    //3、隐式转换法    Person p5 = 10;//有参构造函数调用    //相当于Person p5 = Person(10);    Person p6 = p5;//拷贝构造函数调用}int main(){    fun_p();}</code></pre><blockquote><p>Person(10);</p><p>匿名对象：当前执行结束会立即被系统回收（执行析构函数）</p><p>Person(p3);</p><p>不要利用拷贝构造函数，舒适化匿名对象，编译器会认为是一个对象声明（Person（p3）==Person p3；）</p></blockquote><blockquote><p>调用默认构造函数时候，不要加（）</p><p>因为下面这行代码，编译器会认为是一个函数的声明</p><p>Person p1();</p></blockquote><h4 id="3-拷贝构造函数调用时机"><a href="#3-拷贝构造函数调用时机" class="headerlink" title="3.拷贝构造函数调用时机"></a>3.拷贝构造函数调用时机</h4><p>C++中拷贝构造函数调用时机通常有三种情况</p><ul><li>使用一个已经创建完毕的对象来初始化一个新对象</li><li>值传递的方式给函数参数传值</li><li>以值方式返回局部对象</li></ul><h4 id="4-构造函数调用规则"><a href="#4-构造函数调用规则" class="headerlink" title="4.构造函数调用规则"></a>4.构造函数调用规则</h4><p>默认情况下，C++编译器至少给一个类添加3个函数</p><ol><li>默认构造函数（无参，函数体为空）</li><li>默认析构函数（无参，函数体为空）</li><li>默认拷贝构造函数，对属性进行值拷贝</li></ol><p>构造函数调用规则如下：</p><ul><li>如果用户定义有参构造函数，C++不在提供默认无参构造，但是会提供默认拷贝构造</li><li>如果用户定义拷贝构造函数，C++不会再提供其他构造函数</li></ul><h4 id="5-深拷贝与浅拷贝"><a href="#5-深拷贝与浅拷贝" class="headerlink" title="5.深拷贝与浅拷贝"></a>5.深拷贝与浅拷贝</h4><p>浅拷贝：简单的赋值拷贝操作</p><p>深拷贝：在堆区重新申请空间，进行拷贝操作</p><blockquote><p> 编译器提供的拷贝构造函数会做浅拷贝操作</p><p> 如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p></blockquote><h4 id="6-初始化列表"><a href="#6-初始化列表" class="headerlink" title="6.初始化列表"></a>6.初始化列表</h4><p>用来初始化属性 </p><pre class=" language-c++"><code class="language-c++">class Person{public:    Person(int x,int y,int z):mA(x),mB(y),mC(z)//初始化列表    {    }    int mA;    int mB;    int mC;};void fun_p()//调用{    Person p(3,2,1);}</code></pre><h4 id="7-类对象作为类成员"><a href="#7-类对象作为类成员" class="headerlink" title="7.类对象作为类成员"></a>7.类对象作为类成员</h4><p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p><pre class=" language-c++"><code class="language-c++">class A {}class B {    A a;}</code></pre><p>对象成员会先构造自身类（class A），再构造本类（class  B）</p><p>对象成员会先析构本类（class B），再析构自身类（class A）</p><p>构造和析构的顺序：A构造 -&gt; B构造 -&gt; B析构 -&gt; A析构 </p><h4 id="8-静态成员"><a href="#8-静态成员" class="headerlink" title="8.静态成员"></a>8.静态成员</h4><p>静态成员就是在成员变量和成员函数前加上关键字static,称为静态成员</p><p>静态成员分为：</p><ul><li>静态成员变量<ul><li>所有对象共享同一份数据</li><li>在编译阶段分配内存</li><li>类内声明，类外初始化</li></ul></li><li>静态成员函数<ul><li>所有对象共享同一个函数</li><li>静态成员函数只能访问静态成员变量</li></ul></li></ul><pre class=" language-c++"><code class="language-c++">class Person{public:    static int mA;//类内声明private:    static int mB;//静态成员变量也是有访问权限的，在类外就不能访问};int Person::mA = 11;//类外初始化int Person::mB = 13;int main(){    Person p;    Person p1;    p1.mA = 12;//共享同一份数据    cout << p.mA << endl;//结果为12    cout << Person::mA << endl;//结果为12}</code></pre><p>静态成员变量不属于某个对象，所有对象共享一份数据</p><p>静态成员变量有两种访问方式：</p><ol><li><p>通过对象进行访问：p1.mA</p></li><li><p>通过类名进行访问：Person::mA</p></li></ol><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <string>using namespace std;class Person{public:    static void func(int test_dm)//静态成员函数    {        //dm = test_dm;无法访问非静态成员变量        mm = test_dm;        cout << "静态成员函数被调用" << endl;    }    static int mm;//声明一个静态成员变量    int dm;//声明一个普通成员变量private:    static void private_func()//私有静态成员函数不能被类外部访问，也是有访问权限的    {        cout << "私有静态成员函数被调用" << endl;    }};int Person::mm = 10;void assign(){    //静态成员变量的调用方式    Person p;    p.func(6);//1、通过对象调用    Person::func(5);//2、通过类名调用}int main(){    assign();    Person test_p;    cout << test_p.mm << endl;//可以正常使用，结果为5}</code></pre><h3 id="3、C-对象模型和this指针"><a href="#3、C-对象模型和this指针" class="headerlink" title="3、C++对象模型和this指针"></a>3、C++对象模型和this指针</h3><h4 id="1、成员变量和成员函数的分开储存"><a href="#1、成员变量和成员函数的分开储存" class="headerlink" title="1、成员变量和成员函数的分开储存"></a>1、成员变量和成员函数的分开储存</h4><p>类内的成员变量和成员函数分开存储；只有<strong>非静态成员变量</strong>才属于类的对象上</p><p>空对象占用内存空间为：1</p><p>C++编译器会给每个空对象分配一个字节的空间，是为了区分空对象的内存位置</p><h4 id="2、this指针的概念"><a href="#2、this指针的概念" class="headerlink" title="2、this指针的概念"></a>2、this指针的概念</h4><p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码<br>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p><p>C++通过提供特殊的对象指针，<strong>this指针指向被调用的成员函数所属的对象</strong></p><p>this指针是隐含每一个非静态成员函数内的一种指针</p><p>this指针不需要定义，直接使用即可</p><p>this指针的用途：</p><ul><li>当形参和成员变量同名时，可用this指针来区分</li><li>在类的非静态成员函数中返回对象本身，可使用return*this</li></ul><pre class=" language-c++"><code class="language-c++">class Person{public:    Person(int m_age)//有参构造函数    {        //m_age = m_age;命名冲突        this->m_age = m_age;//用this指针就可以解决    }    Person &PersonAdd(Person &p)//如果要返回对象就要用引用类型    //Person PersonAdd(Person &p)用值的方式返回，会创建新的对象    {        this->m_age += p.m_age;        return *this;//返回的是对用对象本身    }    int m_age;};void test_1(){    Person p(18);    cout << p.m_age << endl;}void test_2(){    Person p1(3);    Person p2(4);    //链式编程思想    p2.PersonAdd(p1).PersonAdd(p1);//因为返回的是调用对象本身，所以可以一直追加    cout << p2.m_age << endl;//结果就为10}int main(){    test_1();    test_2();}</code></pre><h4 id="3-空指针调用成员函数"><a href="#3-空指针调用成员函数" class="headerlink" title="3.空指针调用成员函数"></a>3.空指针调用成员函数</h4><pre class=" language-c++"><code class="language-c++">class Person{public:    void showName()    {        cout << "this is Person class" << endl;    }    void showPersonage()    {        //报错原因是因为传入指针为空        if(this == NULL)//提高代码健壮性做空指针判断        {            return;        }        cout << m_Age << endl;//相当于cout << this->m_Age << endl;    }    int m_Age;};void test_1(){    Person *p = NULL;    p->showName();    p->showPersonage();//空指针无法访问成员，就是有this指针就不能访问}int main(){    test_1();}</code></pre><h4 id="4-const修饰成员函数"><a href="#4-const修饰成员函数" class="headerlink" title="4.const修饰成员函数"></a>4.const修饰成员函数</h4><p>常函数：</p><ul><li>成员函数后加const后我们称为这个函数为常函数</li><li>常函数内不可以修改成员属性</li><li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li></ul><p>常对象：</p><ul><li>声明对象前加const称该对象为常对象</li><li>常对象只能调用常函数</li></ul><pre class=" language-c++"><code class="language-c++">class Person{public:    void showPersonage() const//常函数，此const本质修饰的是this指针    {        //m_Age  = 18;m_Age就不能被修改        //相当于this->m_Age        //指针的本质是指针常量：指向是不能修改的（指向调用对象）        m_Age_cost = 99;    }    void commen_fun()    {    }    int m_Age;    mutable int m_Age_cost;//有mutable修饰的是特殊变量，可以在常函数中修改};void test_1(){    const Person p;//常对象    //p.m_Age=100;    p.m_Age_cost=100;//m_Age_cost是特殊值，在常对象下也可以修改    //p.commen_fun();再普通函数中可以修改属性，所以常对象不能调用普通函数}int main(){    test_1();}</code></pre><h3 id="4、友元"><a href="#4、友元" class="headerlink" title="4、友元"></a>4、友元</h3><p>友元的目的就是让一个函数或者类访问另一个类中私有成员</p><p>友元的关键字为friend</p><p>友元的三种实现</p><ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul><h4 id="1-全局函数作友元"><a href="#1-全局函数作友元" class="headerlink" title="1.全局函数作友元"></a>1.全局函数作友元</h4><pre class=" language-c++"><code class="language-c++">class Building{    //frirnd_fun全局函数是Bui1ding好朋友，可以访问Building中私有成员    friend void frirnd_fun(Building &building);//如此定义友元    //...}</code></pre><h4 id="2-类作友元"><a href="#2-类作友元" class="headerlink" title="2.类作友元"></a>2.类作友元</h4><pre class=" language-c++"><code class="language-c++">class Building;//避免Building *building;报错，要提前声明一下class GoodGay{public:    GoodGay();    void visit();//参观函数访问Building中的属性    Building *building;};class Building{    //GoodGay 设置为友元    friend class GoodGay;public:    Building();public:    string m_SittingRoom;//客厅private:    string m_BedRoom;};Building::Building()//类外编写构造函数{    m_SittingRoom="客厅";    m_BedRoom="卧室";}GoodGay::GoodGay()//类外编写构造函数{    //创建建筑物对象    building = new Building;}void GoodGay::visit()//类外编写成员函数{    cout << "friend正在访问" << building->m_SittingRoom << endl;    cout << "friend正在访问" << building->m_BedRoom << endl;}void test_1(){    GoodGay gay;    gay.visit();}int main(){    test_1();}</code></pre><h4 id="3-成员函数作友元"><a href="#3-成员函数作友元" class="headerlink" title="3.成员函数作友元"></a>3.成员函数作友元</h4><pre class=" language-c++"><code class="language-c++">//告诉编译器GoodGay类下的visit成员函数作为本类的好朋友，可以访问私有成员class Building{    friend void GoodGay:visit();    //...}</code></pre><h3 id="5、运算符重载"><a href="#5、运算符重载" class="headerlink" title="5、运算符重载"></a>5、运算符重载</h3><p>实现两个自定义数据类型的运算</p><h4 id="1-加号运算符重载"><a href="#1-加号运算符重载" class="headerlink" title="1.加号运算符重载"></a>1.加号运算符重载</h4><pre class=" language-c++"><code class="language-c++">class Person{public:    //1、成员函数重载+号    Person operator+(Person &p)    {        Person temp;        temp.m_A = this->m_A + p.m_A:        temp.m_B = this->m_B + p.m_B;        return temp;    }    int m_A;    int m_B;}//2、全局函数的+号重载Person operator+(Person &p1,Person &p2){    Person temp;    temp.m_A = p1.m_A + p2.m_A;    temp.m_B = p1.m_B + p2.m_B;    return temp;}//运算符重载，可以发生函数重载Person operator+(Person &p1,int num){    Person temp:    temp.m_A = p1.m_A + num;    temp.m_B = p1.m_B + num;    return temp;}void test0l(){    Person p1;    p1.mA=10:    p1.mB=10:    Person p2;    p2.mA=10:    p2.mB=10:    Person p3 =pl + p2;//+号重载之后才不会报错}</code></pre><blockquote><p>成员函数重载本质调用</p><p>Person p3 p1.operator+(p2);</p><p>全局函数重载本质调用</p><p>Person p3 operator+(p1,p2);</p></blockquote><h4 id="2-左移运算符重载"><a href="#2-左移运算符重载" class="headerlink" title="2.左移运算符重载"></a>2.左移运算符重载</h4><blockquote><p>利用成员函数重载左移运算符 p.operator &lt;&lt; (cout) 简化版本 p &lt;&lt; cout</p><p>不会利用成员函数重载&lt;运算符，因为无法实现cout在左侧</p><p>智能利用全局函数重载左移运算符</p></blockquote><pre class=" language-c++"><code class="language-c++">class Person{    friend ostream &operator<<(ostream &out,Person &p);//设置为友元public:    Person(int a,int b)    {        this->m_A = a;        this->m_B = b;    }    //成员函数实现不了 p << cout 不是我们想要的效果    //void operator<<(Person&p){}private:    int m_A;    int m_B;};ostream&operator<<(ostream&cout,Person&p)//本质operator<<(cout,p){    cout << "mA=" << p.mA << "mB=" << p.mB;    return cout;}</code></pre><h4 id="3-递增运算符重载"><a href="#3-递增运算符重载" class="headerlink" title="3.递增运算符重载"></a>3.递增运算符重载</h4><pre class=" language-c++"><code class="language-c++">class MyInteger{public:    MyInteger()    {        m_Num =0;//初始化属性    }    //重载前置++运算符    MyInteger & operator++()//返回引用为了一直对一个数据进行递增    {        m_Num++;//先做++        return *this;//再做返回    }    //重载后置++运算符    MyInteger operator++(int)//用于区分后置，int代表占位运算符    {        MyInteger temp = *this;//局部对象，运行完直接被删除无法返回对象        m_Num++;//先做++        return temp;//再做返回}private:    int m_Num;};void test_l(){    MyInteger myint;    cout << ++myint << endl;}int main(){    test_1();}</code></pre><h4 id="4-赋值运算符重载"><a href="#4-赋值运算符重载" class="headerlink" title="4.赋值运算符重载"></a>4.赋值运算符重载</h4><p>C++编译器至少给一个类添加4个函数</p><ol><li>默认构造函数(无参，函数体为空)</li><li>默认析构函数(无参，函数体为空)</li><li>默认拷贝构造函数，对属性进行值拷贝</li><li>赋值运算符operator=,对属性进行值拷贝</li></ol><p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p><pre class=" language-c++"><code class="language-c++">class Person{public:    Person(int age)    {    m_Age = new int(age);//将年龄数据开辟到堆区    }    Person &operator = (Person &p)//重载赋值运算符    {        if (m_Age != NULL)        {            delete m_Age;            m_Age = NULL;        }        //编泽器提供的代码是浅拷贝        //m_Age =p.m_Age;               m_Age = new int(*p.m_Age); //提供深拷贝解决浅拷贝的问题        return *this;//返回自身    }    ~Person()//析构函数清理内存    {        if (m_Age !NULL)        {            delete m_Age;            m_Age NULL;        }}int *m_Age;//年龄的指针};void teste1(){    Person p1(18);    Person p2(20);    Person p3(30);    p3=p2=p1;//赋值操作    cout<<"p1的年龄为："<*p1.m_Age<<end1;    cout<<"p2的年龄为："<<*p2.m_Age<end1;    cout<<"p3的年龄为："<<*p3.m_Age<end1;//此时p1、p2、p3应该都为18}</code></pre><h4 id="5-关系运算符重载"><a href="#5-关系运算符重载" class="headerlink" title="5.关系运算符重载"></a>5.关系运算符重载</h4><h4 id="6-函数调用运算符重载"><a href="#6-函数调用运算符重载" class="headerlink" title="6.函数调用运算符重载"></a>6.函数调用运算符重载</h4><pre class=" language-c++"><code class="language-c++">class Myfun{public:    int operator()(int num1,int num2)    {        return num1+num2;    }};void test_1(){    Myfun fun1;    int result = fun1(12,15);//也称为仿函数，在stl经常使用    cout << result << endl;    //匿名函数对象，Myfun()用完就会销毁代替了fun1    //匿名对象：类名+小括号    cout << Myfun()(10,13) << endl;}int main(){    test_1();}</code></pre><h3 id="6、继承"><a href="#6、继承" class="headerlink" title="6、继承"></a>6、继承</h3><p>语法:<code>class 子类 : 继承方式（public） 父类</code></p><h4 id="1-继承方式"><a href="#1-继承方式" class="headerlink" title="1.继承方式"></a>1.继承方式</h4><ul><li>公共继承（public）</li><li>保护继承（protected）</li><li>私有继承（private）</li></ul><img src="https://gitee.com/sainthood2077/cloudimg/raw/main/images/image-20230105103413344.png" alt="image-20230105103413344" style="zoom:50%;"><blockquote><p>1、私有属性，无论哪种继承都无法访问</p><p>2、公有继承：父类到子类属性权限无变化</p><p>3、保护继承：父类公有变子类保护</p><p>4、私有继承：父类公有、保护变子类私有</p></blockquote><p><strong>父类中的私有属性也会被继承，只是被隐藏无法访问</strong></p><h4 id="2-继承中的构造与析构顺序"><a href="#2-继承中的构造与析构顺序" class="headerlink" title="2.继承中的构造与析构顺序"></a>2.继承中的构造与析构顺序</h4><p>当创造子类创造对象，也会调用父类的构造函数</p><pre class=" language-c++"><code class="language-c++">class Base{public:    Base()//基类构造函数    {cout << "Base的构造函数" << endl;}    ~Base()//基类析构函数    {cout << "Base的析构函数" << endl;}};class Son : public Base{public:    Son()//子类构造函数    {cout << "Son的构造函数" << endl;}    ~Son()//子类析构函数    {cout << "Son的析构函数" << endl;}};void test_1(){    Son son1;}//运行结果//Base的构造函数//Son的构造函数//Son的析构函数//Base的析构函数</code></pre><h4 id="3-继承同名成员处理方式"><a href="#3-继承同名成员处理方式" class="headerlink" title="3.继承同名成员处理方式"></a>3.继承同名成员处理方式</h4><ul><li><p>访问子类同名成员，直接访问即可</p></li><li><p>访问父类同名成员，需要加作用域</p></li></ul><pre class=" language-c++"><code class="language-c++">class Base{public:    Base()    {m_age = 155;}    int m_age;};class Son : public Base{public:    Son()    {m_age = 156;}    int m_age;};void test_1(){    Son son1;    son1.Base::m_age;    cout << son1.Base::m_age << endl;//可以访问到155}</code></pre><h4 id="4-继承同名静态成员处理方式"><a href="#4-继承同名静态成员处理方式" class="headerlink" title="4.继承同名静态成员处理方式"></a>4.继承同名静态成员处理方式</h4><ul><li><p>访问子类同名静态成员，直接访问即可</p></li><li><p>访问父类同名静态成员，需要加作用域</p></li><li><p>静态成员还可以直接通过类名访问</p></li><li><p>访问静态函数同理</p></li></ul><pre class=" language-c++"><code class="language-c++">class Base{public:    Base()    {m_age = 15;}    static int m_age;};int Base::m_age;class Son : public Base{public:    Son()    {m_age = 156;}    int m_age;};void test_1(){    Son son1;    son1.Base::m_age;    cout << son1.Base::m_age << endl;//通过创建对象访问   结果为15    cout << Son::Base::m_age << endl;//通过类名访问       结果为15    //只有静态成员可以通过类名访问    //cout << Son::m_age << endl;//会报错，非静态成员不可以}</code></pre><h4 id="5-多继承语法"><a href="#5-多继承语法" class="headerlink" title="5.多继承语法"></a>5.多继承语法</h4><p>C++允许一个类继承多个类工</p><p>语法：<code>c1ass 子类：继承方式父类1，继承方式父类2…</code></p><blockquote><p>多继承可能会引发父类中有同名成员出现，<u>需要加作用域区分</u>,<strong>C++实际开发中不建议用多继承</strong></p></blockquote><h4 id="6-菱形继承"><a href="#6-菱形继承" class="headerlink" title="6.菱形继承"></a>6.菱形继承</h4><p>两个派生类继承同一个基类，又有某个类同时继承者两个派生类，这种继承被称为<strong>菱形继承</strong>，或者<strong>钻石继承</strong></p><p>问题：</p><p>1、两个孙子类继承了两份基类的属性，会产生二义性，需要加作用域解决</p><p>2、孙子类中的基类属性，要通过**虚继承(virtual关键字)**，孙子类用该属性最新赋予的数据</p><blockquote><p>class sheep ：<strong>virtual</strong> public Animal {};</p><p>此时，class Animal{}；称为<strong>虚基类</strong></p></blockquote><h2 id="十一、多态"><a href="#十一、多态" class="headerlink" title="十一、多态"></a>十一、多态</h2><p>多态是C++面向对象三大特性之一</p><p>多态分为两类</p><ul><li><p><strong>静态多态</strong>：函数重载和运算符重载属于静态多态，复用函数名</p></li><li><p><strong>动态多态</strong>：派生类和虚函数实现运行时多态</p></li></ul><p>静态多态和动态多态区别：</p><ul><li><p>静态多态的函数地址<strong>早绑定</strong>：编译阶段确定函数地址</p></li><li><p>动态多态的函数地址<strong>晚绑定</strong>：运行阶段确定函数地址</p></li></ul><pre class=" language-c++"><code class="language-c++">class Base_animal{public:    virtual void speak()//虚函数    {cout << "发出了动物叫" << endl;}};class Cat : public Base_animal{public:    //此（派生类）virtual可写可不写，基类必须写    virtual void speak()//重写函数:返回值 函数名 参数列表要完全一致    {cout << "发出了猫叫" << endl;}};void Speak(Base_animal &animal)//基类的引用指向->派生类的对象{animal.speak();}void test_1(){    Cat cat;    Speak(cat);}</code></pre><blockquote><p><strong>动态多态满足条件：</strong></p><ol><li>有继承关系</li><li>子类重写父类的虚函数</li></ol><p><strong>使用</strong>：基类指针或者引用指向子类对象</p></blockquote><p>原理：</p><p>基类中virtual关键字定义了虚函数，则会生成一个虚函数指针（记录虚函数表中的函数位置），指向虚函数表；在派生类中进行继承基类，包括虚函数指针也会被继承，并且在基类中重写该函数，此时，派生类中的虚函数指针会指向新的虚函数表中的函数位置，当基类指针或引用指向派生类的对象时，会执行派生的虚函数，由此发生多态</p><p>特点：组织结构清晰、可读性强、便于扩展和维护</p><p><strong>C++开发中建议多用多态结构编写</strong></p><h3 id="1、案例一：计算器类"><a href="#1、案例一：计算器类" class="headerlink" title="1、案例一：计算器类"></a>1、案例一：计算器类</h3><p>开闭原则：对扩展进行开放，对修改进行关闭</p><pre class=" language-c++"><code class="language-c++">class Calculator//普通方法,编写一个计算器{public:    int getResult(string oper)    {        if (oper == "+")        {return num1 + num2;}        else if (oper == "-")        {return num1 - num2;}        else if (oper == "*")        {return num1 * num2;}        else if (oper == "/")        {return num1 / num2;}    }    int num1;    int num2;};void test(){    Calculator c1;    c1.num1 = 23;    c1.num2 = 12;    cout << c1.getResult("+") << endl;}</code></pre><pre class=" language-c++"><code class="language-c++">class Abstract_Calculator//计算器（基）类{public:    virtual int get_Result()//虚函数    {return 0;}    int m_Num1;    int m_Num2;};class Plus_Calculator : public Abstract_Calculator//继承{public:    virtual int get_Result()//重写    {return m_Num1 + m_Num2;}};class Sub_Calculator : public Abstract_Calculator//继承{public:    virtual int get_Result()//重写    {return m_Num1 - m_Num2;}};class Mul_Calculator : public Abstract_Calculator//继承{public:    virtual int get_Result()//重写    {return m_Num1 * m_Num2;}};class Division_Calculator : public Abstract_Calculator//继承{public:    virtual int get_Result()//重写    {return m_Num1 / m_Num2;}};void test(){    //Abstract_Calculator * abc = new Mul_Calculator;//乘法，创建一个对象在堆区    //Abstract_Calculator * abc = new Plus_Calculator;//加法，创建一个对象在堆区    //Abstract_Calculator * abc = new Sub_Calculator;//减法，创建一个对象在堆区    Abstract_Calculator * abc = new Division_Calculator;//除法，创建一个对象在堆区    abc->m_Num1 = 75;    abc->m_Num2 = 2;    cout << abc->get_Result() << endl;    delete abc;//记得销毁堆区内存}int main(){    test();    system("pause");    return 0;}</code></pre><h3 id="2、纯虚数和抽象类"><a href="#2、纯虚数和抽象类" class="headerlink" title="2、纯虚数和抽象类"></a>2、纯虚数和抽象类</h3><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容因此可以将虚函数改为<strong>纯虚函数</strong></p><p>纯虚函数语法：<code>virtual 返回值类型  函数名（参数列表）= 0；</code></p><blockquote><p>当类中有了<strong>纯虚函数</strong>，这个类也称为<strong>抽象类</strong></p></blockquote><p>抽象类特点：</p><ul><li><strong>无法实例化对象</strong></li><li><strong>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</strong></li></ul><pre class=" language-c++"><code class="language-c++">class Abstract_Calculator//抽象列（包含了get_Result()这个纯虚函数），无法实例化对象{public:    virtual int get_Result() = 0;//纯虚函数    int m_Num1;    int m_Num2;};</code></pre><h3 id="3、虚析构和纯虚构"><a href="#3、虚析构和纯虚构" class="headerlink" title="3、虚析构和纯虚构"></a>3、虚析构和纯虚构</h3><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p><p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p><p>虚析构和纯虚析构共性：</p><ul><li><p>可以解决父类指针释放子类对象</p></li><li><p>都需要有具体的函数实现</p></li></ul><p>虚析构和纯虚析构区别：</p><ul><li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li></ul><p>虚析构语法：<code>virtual类名( ) { }</code></p><p>纯虚析构语法：</p><p><code>virtual 类名 () = 0 ;</code></p><p><code>类名::类名( ) { }</code></p><pre class=" language-c++"><code class="language-c++">class Abstract_Animal//计算器抽象类{public:    Abstract_Animal()    {cout << "Animal 的构造函数调用" << endl;}    virtual int speak() = 0;    virtual ~Abstract_Animal()    {cout << "Animal 的析构函数调用" << endl;}    //virtual ~Abstract_Animal() = 0;纯虚析构写法一    string *m_Name;};//Animal :: ~Abstract_Animal()//纯虚析构写法二//{//    cout << "Animal 的析构函数调用" << endl;//}class Cat : public Abstract_Animal{public:    Cat(string name)    {cout << "Cat 的构造函数调用" << endl;        m_Name = new string(name);}    virtual int speak()    {cout << *m_Name << " little cat speaking" << endl;}    ~Cat()    {        if (m_Name != NULL)        {            delete m_Name;            m_Name = NULL;            cout << "Cat 的析构函数调用" << endl;        }    }};void test(){    Abstract_Animal * animal = new Cat("Tommy");    animal->speak();    delete animal;}//    如果没有加虚析构结果为：//Animal 的构造函数调用//Cat 的构造函数调用//Tommy little cat speaking//Animal 的析构函数调用//    加了结果为：//Animal 的构造函数调用//Cat 的构造函数调用//Tommy little cat speaking//Cat 的析构函数调用//Animal 的析构函数调用    </code></pre><h3 id="4、案例二：电脑组装"><a href="#4、案例二：电脑组装" class="headerlink" title="4、案例二：电脑组装"></a>4、案例二：电脑组装</h3><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <string>using namespace std;class Cpu{public:    virtual void calsulate() = 0;};class VidoCard{public:    virtual void display() = 0;};class Memory{public:    virtual void storage() = 0;};class Computer{public:    Computer(Cpu *cp,VidoCard *vc,Memory *me)    {        m_cpu = cp;        m_vidocard = vc;        m_memory = me;    };    void work()    {        m_cpu->calsulate();        m_vidocard->display();        m_memory->storage();    }    ~Computer()    {        if (m_cpu != NULL)        {            delete m_cpu;            m_cpu = NULL;        }        if (m_vidocard != NULL)        {            delete m_cpu;            m_vidocard = NULL;        }        if (m_memory != NULL)        {            delete m_cpu;            m_memory = NULL;        }    }private:    Cpu *m_cpu;    VidoCard *m_vidocard;    Memory *m_memory;};class Intel_Cpu : public Cpu{public:    virtual void calsulate()    {cout << "CPU of Intel is working" << endl;}};class Intel_VideoCard : public VidoCard{public:    virtual void display()    {cout << "VidoCard of Intel is working" << endl;}};class Intel_Memory : public Memory{public:    virtual void storage()    {cout << "Memory of Intel is working" << endl;}};class Lenovo_Cpu : public Cpu{public:    virtual void calsulate()    {cout << "CPU of Lenovo is working" << endl;}};class Lenovo_VideoCard : public VidoCard{public:    virtual void display()    {cout << "VidoCard of Lenovo is working" << endl;}};class Lenovo_Memory : public Memory{public:    virtual void storage()    {cout << "Memory of Lenovo is working" << endl;}};void test(){    Cpu *intel_cpu = new Intel_Cpu;//第一台电脑零件    VidoCard *intel_vidocard = new Intel_VideoCard;    Memory *intel_memory = new Intel_Memory;    Computer *computer1 = new Computer(intel_cpu,intel_vidocard,intel_memory);//组装第一台电脑    computer1->work();    delete computer1;    Computer *computer2 = new Computer(new Lenovo_Cpu,new Lenovo_VideoCard,new Lenovo_Memory);//组装第二台电脑    computer2->work();    delete computer2;}int main(){    test();    system("pause");    return 0;}</code></pre><h2 id="十二、文件操作"><a href="#十二、文件操作" class="headerlink" title="十二、文件操作"></a>十二、文件操作</h2><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放，通过文件可以将数据持久化</p><p>C++中对文件操作需要包含头文件<fstream></fstream></p><p>文件类型分为两种：</p><ol><li><p>文本文件：文件以文本的<strong>ASCII码</strong>形式存储在计算机中</p></li><li><p>二进制文件：文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们</p></li></ol><p>操作文件的三大类：</p><ol><li><p>ofstream：写操作</p></li><li><p>ifstream：读操作</p></li><li><p>fstream：读写操作</p></li></ol><h3 id="1、文本文件"><a href="#1、文本文件" class="headerlink" title="1、文本文件"></a>1、文本文件</h3><h4 id="1-写文件"><a href="#1-写文件" class="headerlink" title="1.写文件"></a>1.写文件</h4><p>写文件步骤如下：</p><ol><li><p>包含头文件</p><p>#include <fstream></fstream></p></li><li><p>创建流对象</p><p>ofstream ofs;</p></li><li><p>打开文件</p><p>ofs.open(“文件路径”，打开方式)；</p></li><li><p>写数据</p><p>of5&lt;&lt;”写入的数据”；</p></li><li><p>关闭文件</p><p>ofs.close()；</p></li></ol><table><thead><tr><th>打开方式</th><th>作用</th></tr></thead><tbody><tr><td>ios::in</td><td>为读文件而打开文件</td></tr><tr><td>ios::out</td><td>为写文件而打开文件</td></tr><tr><td>ios::ate</td><td>初始位置:文件尾</td></tr><tr><td>ios::app</td><td>追加方式写文件</td></tr><tr><td>ios::trunc</td><td>如果文件存在先删除，在创建</td></tr><tr><td>ios::binary</td><td>二进制方式</td></tr></tbody></table><pre class=" language-c++"><code class="language-c++">#include <fstream>int main(){       ofstream ofs;//创建流文件    //以指定模式打开选择文件    ofs.open("E:\\desktop\\txtfile.txt",ios::app | ios::binary);//可以用两种模式一起打开    ofs << endl << "想要写入的内容";//可以先换行再写入    ofs.close();//关闭文件    return 0;}</code></pre><h4 id="2-读文件"><a href="#2-读文件" class="headerlink" title="2.读文件"></a>2.读文件</h4><p>读文件与写文件步骤相似，但是读取方式相对于比较多</p><p>读文件步骤如下：</p><ol><li><p>包含头文件</p><p>#include <fstream></fstream></p></li><li><p>创建流对象</p><p>ifstream ifs;</p></li><li><p>打开文件并判断文件是否打开成功</p><p>ifs.open(“文件路径”打开方式)：</p></li><li><p>读数据</p><p>四种方式读取</p></li><li><p>关闭文件</p><p>ifs.close();</p></li></ol><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <string>#include <fstream>using namespace std;int main(){       ifstream ifs;    ifs.open("E:\\Desktop\\txtfile.txt",ios::in);    if (!ifs.is_open())    {cout << "file is fail to open" << endl;}    char buf[1024]={0};//第一种    while (ifs >> buf){cout<<buf<<endl;}        //char buf[1024]={0};//第二种    //while (ifs.getline(buf,sizeof(buf))){cout<<buf<<endl;}        //string buf;//第三种    //while (getline(ifs,buf)){cout<<buf<<endl;}    //char c;//第四种，不推荐效率太低    //while ((c = ifs.get()) != EOF ){cout<<c<<endl;}    ifs.close();        system("pause");    return 0;}</code></pre><h3 id="2、二进制文件"><a href="#2、二进制文件" class="headerlink" title="2、二进制文件"></a>2、二进制文件</h3><p>打开方式指定为：iso::binary</p><h4 id="1-写文件-1"><a href="#1-写文件-1" class="headerlink" title="1.写文件"></a>1.写文件</h4><p>二进制方式写文件主要利用流对象调用成员函数write</p><p>函数原型：<code>ostream&amp; write(const char *buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><pre class=" language-c++"><code class="language-c++">class Person{public:    char m_Name[64];    int m_Age;}void teste1()//二进制文件写文件{    ofstream=ofs("person.txt",ios:out ios:binary);    //ofs.open("person.txt",ios:out ios:binary);//打开文件    Person p={"张三"，18};    ofs.write((const char *)&p,sizeof(p));//写文件    ofs.close();}</code></pre><h4 id="2-读文件-1"><a href="#2-读文件-1" class="headerlink" title="2.读文件"></a>2.读文件</h4><p>二进制方式读文件主要利用流对象调用成员函数read</p><p>函数原型：istream&amp;read(char*buffer,int len);</p><p>参数解释：字符指针ouffer指向内存中一段存储空间。len是读写的字节数</p><pre class=" language-c++"><code class="language-c++">class Person{public:    char m_Name[64];    int m_Age;};void teste1(){    ifstream ifs("person.txt",ios:in ios:binary);    if(Iifs.is_open()）    {cout << "文件打开失败" << endl;}    Person p;    ifs.read((char *)&p,sizeof(p));    cout << "姓名：" << p.m_Name << "年龄：" << p.mAge <<endl;}</code></pre><h2 id="十三、数据类型转换"><a href="#十三、数据类型转换" class="headerlink" title="十三、数据类型转换"></a>十三、数据类型转换</h2><p>当运算符的操作数具有不同的数据类型时，C++ 会自动将它们转换为相同的数据类型。当它这样做时，遵循一组规则。</p><p>就像军队的军官有军阶一样，数据类型也可以按等级排名。如果一个数字数据类型可以容纳的数字大于另一个数据类型，那么它的排名就高于后者。例如，float 类型就超越了 int 类型，而 double 类型又超越了 float 类型。下表列出了从高到低排列的数据类型。</p><table><thead><tr><th>long double</th></tr></thead><tbody><tr><td>double</td></tr><tr><td>float</td></tr><tr><td>unsigned long long int</td></tr><tr><td>long long int</td></tr><tr><td>unsigned long int</td></tr><tr><td>long int</td></tr><tr><td>unsigned int</td></tr><tr><td>int</td></tr></tbody></table><p>上表排名的一个例外是当 int 和 long int 的大小相同时。在这种情况下，unsigned int 将超越 long int，因为它可以保存更高的值。</p><h3 id="1-隐式-自动数据类型转换"><a href="#1-隐式-自动数据类型转换" class="headerlink" title="1.隐式/自动数据类型转换"></a>1.隐式/自动数据类型转换</h3><p>当 C++ 使用运算符时，它会努力将操作数转换为相同的类型。这种<strong>隐式或自动的转换称为类型强制</strong>。</p><p>现在来看一看管理数学表达式评估的具体规则：</p><ul><li><p><strong>规则 1</strong>：char、short 和 unsigned short 值自动升级为 int 值。细心的读者可能已经注意到，char、short 和 unsigned short 都未出现在表 1 中，这是因为无论何时在数学表达式中使用这些数据类型的值，它们都将自动升级为 int 类型。</p></li><li><p><strong>规则 2</strong>：当运算符使用不同数据类型的两个值时，较低排名的值将被升级为较高排名值的类型。在下面的表达式中，假设 years 是一个 int 变量，而 interestRate 是一个 double 变量</p><pre class=" language-c++"><code class="language-c++">years * interestRate </code></pre><p>在乘法发生之前，years 中的值将升级为 double 类型。</p></li><li><p><strong>规则 3</strong>：当表达式的最终值分配给变量时，它将被转换为该变量的数据类型。在下面的语句中，假设 area 是一个 long int 长整型变量，而 length 和 width 都是 int 整型变量：</p><pre class=" language-c++"><code class="language-c++">area = length * width;</code></pre></li></ul><p>因为存储在 length 和 width 中的值是相同的数据类型，所以它们都不会被转换为任何其他数据类型。但是，乘法的结果将被升级为 long int 类型，这样才可以存储到 area 中。</p><p>但是，如果接收值的变量的数据类型低于接收的值，那该怎么办呢？在这种情况下，值将被降级为变量的类型。如果变量的数据类型没有足够的存储空间来保存该值，则该值的一部分将丢失，并且该变量可能会收到不准确的结果。</p><p>我们知道，如果接收值的变量想要的是一个整数，而赋给它的值是一个浮点数，那么当转换为 int 并存储在变量中时，浮点值将被截断。这意味着小数点后的所有内容都将被丢弃。示例如下：</p><pre class=" language-c++"><code class="language-c++">int x;double y = 3.75;x = y; // x被赋值为3，y仍然保留3.75</code></pre><p>但是，重要的是要了解，当变量值的数据类型更改时，它不会影响变量本身。例如，来看下面的代码段。</p><pre class=" language-c++"><code class="language-c++">int quantity1 = 6;double quantity2 = 3.7;double total;total = quantity1 + quantity2;</code></pre><p>在 C++ 执行上述加法之前，它会将一个 quantity1 值的副本移动到其工作空间中，并将其转换为 double 类型。然后把 6.0 和 3.7 相加，并且将结果值 9.7 存储到 total 中。但是，变量 quantity1 保持为 int，存储在存储器中的值保持不变，它仍然是整数 6。</p><h3 id="2-手动强制转换"><a href="#2-手动强制转换" class="headerlink" title="2.手动强制转换"></a>2.手动强制转换</h3><p>有时程序员想要自己更改值的数据类型，这可以通过使用类型强制转换表达式来完成。类型强制转换表达式允许手动升级或降级值。它的一般格式如下：</p><pre class=" language-c++"><code class="language-c++">static_cast<DataType>(Value)</code></pre><p>其中 Value 是要转换的变量或文字值，DataType 是要转换的目标数据类型。以下是使用类型转换表达式的代码示例：</p><pre class=" language-c++"><code class="language-c++">double number = 3.7;int val;val = static_cast<int>(number);</code></pre><p>上述代码定义了两个变量：double 类型的 number 和 int 类型的 val。第 3 个语句中的类型转换表达式返回 number 中的值的副本，转换为 int。当 double 或 float 类型的值转换为 int 时，小数部分被截断，因此该语句将 3 存储在 val 中。而 number 的值仍为 3.7，保持不变。</p><p>类型转换表达式在 C++ 不能自动执行所需转换的情况下很有用。</p><p>下面的程序显示了使用类型强制转换表达式来防止发生整除法的示例。</p><pre class=" language-c++"><code class="language-c++">//This program uses a type cast to avoid an integer division.#include <iostream>using namespace std;int main(){        int books, months;    double booksPerMonth;    // Get user inputs        cout << "How many books do you plan to read? ";        cin >> books;        cout << "How many months will it take you to read them? ";        cin >> months;        // Compute and display books read per month        booksPerMonth = static_cast<double>(books) / months;        cout << "That is " << booksPerMonth << " books per month.\n";        return 0;}</code></pre><p>程序输出结果：</p><pre><code>How many books do you plan to read? 30How many months will it take you to read them? 7That is 4.28571 books per month.</code></pre><p>其中，使用类型强制转换表达式的语句是：</p><pre class=" language-c++"><code class="language-c++">booksPerMonth = static cast<double>(books) / months;</code></pre><p>变量 books 是一个整数，但是它的值的副本在除法运算之前被转换为 double 类型。如果没有此类型转换表达式，则将执行整除法，导致错误的答案。值得一提的是，如果按以下语句改写此行，则整除法仍然会发生：</p><pre class=" language-c++"><code class="language-c++">booksPerMonth = static_cast <double> (books / months);</code></pre><p>因为括号内的操作在其他操作之前完成，所以除法运算符将对其两个整数操作数执行整除法，books / month 表达式的结果将是 4，然后将 4 转换为 double 类型的值 4.0，这就是将赋给 booksPerMonth 的值。</p><p>警告，为了防止发生整除法，在除法运算之前，其中一个操作数应该转换为一个 double 双精度值。这将强制 C++ 自动将其他操作数的值也转换为双精度值。</p><p>下面的程序显示了类型强制转换的另一种用法：</p><pre class=" language-c++"><code class="language-c++">//This program prints a character from its ASCII code.#include <iostream>using namespace std;int main(){    int number = 65;    //Display the value of the number variable    cout << number << endl;    // Use a type cast to display the value of number    // converted to the char data type    cout << static_cast<char>(number) << endl;    return 0;}</code></pre><p>程序输出结果：</p><pre><code>65A</code></pre><p>现在来仔细看一看这个程序。首先，int 变量 number 的值被初始化为值 65，同时将 number 发送到 cout，导致显示 65。随后，类型强制转换表达式用于将 number 的值转换为 char 数据类型，再将其发送到 cout。我们知道，字符作为整数 ASCII 代码存储在内存中。因为数字 65 是字母 A 的 ASCII 码，所以最后的输出语句会显示字母 A。</p><p>注意，C++ 提供了若干种不同类型的强制转换表达式。static_cast 是最常用的类型强制转换表达式。</p><h3 id="3-C-风格和预标准-C-类型强制转换表达式"><a href="#3-C-风格和预标准-C-类型强制转换表达式" class="headerlink" title="3.C 风格和预标准 C++ 类型强制转换表达式"></a>3.C 风格和预标准 C++ 类型强制转换表达式</h3><p>虽然 static_cast 是目前使用最多的类型强制转换表达式，但是 C++ 还支持两种较旧的形式，这也是程序员应该有所了解的，即 C 风格形式和预标准 C++ 形式。</p><p>C 风格的转换将要转换的数据类型放在括号中，位于值要转换的操作数的前面。因为类型转换运算符在操作数前面，所以这种类型转换表示法被称为前缀表示法，示例如下：</p><pre class=" language-c"><code class="language-c">booksPerMonth <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span>books <span class="token operator">/</span> months<span class="token punctuation">;</span></code></pre><p>预标准 C++ 形式类型强制转换表达式也是将要转换的数据类型放在其值要转换的操作数之前，但它将括号放在操作数周围，而不是围绕数据类型。这种类型转换表示法被称为功能性表示法，示例如下：</p><pre class=" language-c"><code class="language-c">booksPerMonth <span class="token operator">=</span> <span class="token keyword">double</span><span class="token punctuation">(</span>books<span class="token punctuation">)</span> <span class="token operator">/</span> months<span class="token punctuation">;</span></code></pre><h2 id="十四、模板"><a href="#十四、模板" class="headerlink" title="十四、模板"></a>十四、模板</h2><p>本阶段主要针对C++<strong>泛型编程</strong>和<strong>STL</strong>技术讲解</p><h3 id="1、函数模板"><a href="#1、函数模板" class="headerlink" title="1、函数模板"></a>1、函数模板</h3><h3 id="2、类模板"><a href="#2、类模板" class="headerlink" title="2、类模板"></a>2、类模板</h3><h2 id="十五、STL"><a href="#十五、STL" class="headerlink" title="十五、STL"></a>十五、STL</h2><h3 id="1、STL-常用容器"><a href="#1、STL-常用容器" class="headerlink" title="1、STL-常用容器"></a>1、STL-常用容器</h3><h3 id="2、STL-函数对象"><a href="#2、STL-函数对象" class="headerlink" title="2、STL-函数对象"></a>2、STL-函数对象</h3><h3 id="3、STL-常用算法"><a href="#3、STL-常用算法" class="headerlink" title="3、STL-常用算法"></a>3、STL-常用算法</h3><h2 id="十六、左值和右值"><a href="#十六、左值和右值" class="headerlink" title="十六、左值和右值"></a>十六、左值和右值</h2><h3 id="1、什么是左值和右值"><a href="#1、什么是左值和右值" class="headerlink" title="1、什么是左值和右值"></a>1、什么是左值和右值</h3><p>首先，让我们避开那些正式的定义。在C++中，一个左值是指向一个指定内存的东西。另一方面，右值就是不指向任何地方的东西。通常来说，右值是暂时和短命的，而左值则活的很久，因为他们以变量的形式（variable）存在。我们可以将左值看作为容器（container）而将右值看做容器中的事物。如果容器消失了，容器中的事物也就自然就无法存在了。<br> 让我们现在来看一些例子：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">666</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//ok</span></code></pre><p>在这里，<code>666</code>是一个右值。一个数字（从技术角度来说他是一个字面常量（literal constant））没有指定的内存地址，当然在程序运行时一些临时的寄存器除外。在该例中，<code>666</code>被赋值（assign）给<code>x</code>，<code>x</code>是一个变量。一个变量有着具体（specific）的内存位置，所以他是一个左值。C++中声明一个赋值（assignment）需要一个左值作为它的左操作数（left operand）：这完全合法。<br> 对于左值<code>x</code>，你可以做像这样的操作：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">*</span> y <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//ok</span></code></pre><p>在这里我通过取地址操作符<code>&amp;</code>获取了<code>x</code>的内存地址并且把它放进了<code>y</code>。<code>&amp;</code>操作符需要一个左值并且产生了一个右值，这也是另一个完全合法的操作：在赋值操作符的左边我们有一个左值（一个变量），在右边我们使用取地址操作符产生的右值。<br> 然而，我们不能这样写：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> y<span class="token punctuation">;</span><span class="token number">666</span> <span class="token operator">=</span> y<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//error!</span></code></pre><p>可能上面的结论是显而易见的，但是从技术上来说是因为<code>666</code>是一个字面常量也就是一个右值，它没有一个具体的内存位置（memory location），所以我们会把<code>y</code>分配到一个不存在的地方。<br> 下面是GCC给出的变异错误提示：</p><blockquote><p>error: lvalue required as left operand of assignment</p></blockquote><p>赋值的左操作数需要一个左值，这里我们使用了一个右值<code>666</code>。<br> 我们也不能这样做：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">*</span> y <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token number">666</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//   error~</span></code></pre><p>GCC给出了以下错误提示：</p><blockquote><p>error: lvalue required as unary ‘&amp;’ operand`</p></blockquote><p><code>&amp;</code>操作符需要一个左值作为操作数，因为只有一个左值才拥有地址。</p><h3 id="2、返回左值和右值的函数"><a href="#2、返回左值和右值的函数" class="headerlink" title="2、返回左值和右值的函数"></a>2、返回左值和右值的函数</h3><p>我们知道一个赋值的左操作数必须是一个左值，因此下面的这个函数肯定会抛出错误：<code>lvalue required as left operand of assignment</code></p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">setValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">6</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// ... somewhere in main() ...</span><span class="token function">setValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error!</span></code></pre><p>错误原因很清楚：<code>setValue()</code>返回了一个右值（一个临时值<code>6</code>），他不能作为一个赋值的左操作数。现在，我们看看如果函数返回一个左值，这样的赋值会发生什么变化。看下面的代码片段（snippet）：</p><pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">int</span> <span class="token keyword">global</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">setGlobal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">global</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// ... somewhere in main() ...</span><span class="token function">setGlobal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">400</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// OK</span></code></pre><p>该程序可以运行，因为在这里<code>setGlobal()</code>返回一个引用（reference），跟之前的<code>setValue()</code>不同。一个引用是指向一个已经存在的内存位置（<code>global</code>变量）的东西，因此它是一个左值，所以它能被赋值。注意这里的<code>&amp;</code>：它不是取地址操作符，他定义了返回的类型（一个引用）。<br> 可以从函数返回左值看上去有些隐晦，它在你做一些进阶的编程例如实现一些操作符的重载（implementing overload operators）时会很有作用，这些知识会在未来的章节中讲述。</p><h3 id="3、左值到右值的转换"><a href="#3、左值到右值的转换" class="headerlink" title="3、左值到右值的转换"></a>3、左值到右值的转换</h3><p>一个左值可以被转换（convert）为右值，这完全合法且经常发生。让我们先用<code>+</code>操作符作为一个例子，根据C++的规范（specification），它使用两个右值作为参数并返回一个右值（译者按：可以将操作符理解为一个函数）。<br> 让我们看下面的代码片段：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">int</span> z <span class="token operator">=</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// ok</span></code></pre><p>等一下，<code>x</code>和<code>y</code>是左值，但是加法操作符需要右值作为参数：发生了什么？答案很简单：<code>x</code>和<code>y</code>经历了一个隐式（implicit）的左值到右值（lvalue-to-rvalue）的转换。许多其他的操作符也有同样的转换——减法、加法、除法等等。</p><h3 id="4、左值引用"><a href="#4、左值引用" class="headerlink" title="4、左值引用"></a>4、左值引用</h3><p>相反呢？一个右值可以被转化为左值吗？不可以，它不是技术所限，而是C++编程语言就是那样设计的。<br> 在C++中，当你做这样的事：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token operator">&amp;</span> yref <span class="token operator">=</span> y<span class="token punctuation">;</span>yref<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// y is now 11</span></code></pre><p>这里将<code>yref</code>声明为类型<code>int&amp;</code>：一个对<code>y</code>的引用，它被称作左值引用（lvalue reference）。现在你可以开心地通过该引用改变<code>y</code>的值了。<br> 我们知道，一个引用必须只想一个具体的内存位置中的一个已经存在的对象，即一个左值。这里<code>y</code>确实存在，所以代码运行完美。<br> 现在，如果我缩短整个过程，尝试将<code>10</code>直接赋值给我的引用，并且没有任何对象持有该引用，将会发生什么？</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">&amp;</span> yref <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// will it work?</span></code></pre><p>在右边我们有一个临时值，一个需要被存储在一个左值中的右值。在左边我们有一个引用（一个左值），他应该指向一个已经存在的对象。但是<code>10</code> 是一个数字常量（numeric constant），也就是一个左值，将它赋给引用与引用所表述的精神冲突。<br> 如果你仔细想想，那就是被禁止的从右值到左值的转换。一个<code>volitile</code>的数字常量（右值）如果想要被引用，需要先变成一个左值。如果那被允许，你就可以通过它的引用来改变数字常量的值。相当没有意义，不是吗？更重要的是，一旦这些值不再存在这些引用该指向哪里呢？<br> 下面的代码片段同样会发生错误，原因跟刚才的一样：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">fnc</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">fnc</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Nope!</span>    <span class="token comment" spellcheck="true">// This works instead:</span>    <span class="token comment" spellcheck="true">// int x = 10;</span>    <span class="token comment" spellcheck="true">// fnc(x);</span><span class="token punctuation">}</span></code></pre><p>我将一个临时值<code>10</code>传入了一个需要引用作为参数的函数中，产生了将右值转换为左值的错误。这里有一个解决方法（workaround），创造一个临时的变量来存储右值，然后将变量传入函数中（就像注释中写的那样）。将一个数字传入一个函数确实不太方便。</p><h3 id="5、常量左值引用"><a href="#5、常量左值引用" class="headerlink" title="5、常量左值引用"></a>5、常量左值引用</h3><p>先看看GCC对于之前两个代码片段给出的错误提示：</p><blockquote><p>error: invalid initialization of non-const reference of type ‘int&amp;’ from an rvalue of type ‘int’</p></blockquote><p>GCC认为引用不是<code>const</code>的，即一个常量。根据C++规范，你可以将一个<code>const</code>的左值绑定到一个右值上，所以下面的代码可以成功运行：</p><pre class=" language-c++"><code class="language-c++">const int& ref = 10;  // OK!</code></pre><p>当然，下面的也是：</p><pre class=" language-c++"><code class="language-c++">void fnc(const int& x){}int main(){    fnc(10);  // OK!}</code></pre><p>背后的道理是相当直接的，字面常量<code>10</code>是<code>volatile</code>的并且会很快失效（expire），所以给他一个引用是没什么意义的。如果我们让引用本身变成常量引用，那样的话该引用指向的值就不能被改变了。现在右值被修改的问题被很好地解决了。同样，这不是一个技术限制，而是C ++人员为避免愚蠢麻烦所作的选择。</p><p><em>应用：C++中经常通过常量引用来将值传入函数中，这避免了不必要的临时对象的创建和拷贝。</em><br> 编译器会为你创建一个隐藏的变量（即一个左值）来存储初始的字面常量，然后将隐藏的变量绑定到你的引用上去。那跟我之前的一组代码片段中手动完成的是一码事，例如：</p><pre class=" language-c++"><code class="language-c++">// the following...const int& ref = 10;// ... would translate to:int __internal_unique_name = 10;const int& ref = __internal_unique_name;</code></pre><p>现在你的引用指向了真实存在的事物（知道它走出作用域外）并且你可以正常使用它，出克改变他指向的值。</p><pre class=" language-c++"><code class="language-c++">const int& ref = 10;std::cout << ref << "\n";   // OK!std::cout << ++ref << "\n"; // error: increment of read-only reference ‘ref’</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像处理任务</title>
      <link href="/2022/12/20/tu-xiang-chu-li-ren-wu/"/>
      <url>/2022/12/20/tu-xiang-chu-li-ren-wu/</url>
      
        <content type="html"><![CDATA[<h3 id="算法与优化具体任务步骤"><a href="#算法与优化具体任务步骤" class="headerlink" title="算法与优化具体任务步骤"></a>算法与优化具体任务步骤</h3><ol><li><p>首先要评估一下这是什么图像处理任务（<strong>分类，检测，分割，识别</strong>等等），结合现有数据，看看该用什么样的算法（深度学习，传统机器学习，还是普通的图像处理就好）。指标提不上去，从源头上看，是不是任务定义的就有问题，比如，要对图片中的猫和狗进行识别，我们把它定义成一个简单的分类问题，但是如果有些图片中有猫又有狗，那整图分类就不好使了，定义成检测问题会不会更好。</p></li><li><p>任务定义好，采用的算法确定好了，就可以准备数据了。不管用深度学习还是传统机器学习，都需要大量的数据进行训练，这一步很重要，怎么强调都不为过，任务定义清楚以后，干净的数据集是整个任务能朝着既定方向行进的基础。</p><p>一般算法工程师不太会直接标注数据，很多是通过外包或者专门的标注人员进行标注，而这些人或因为责任心问题，或因为对任务不了解，他们标注的数据大多不能直接使用，需要检查修正，如果算法工程师直接拿来就用，而正好这批数据标注的不干净，那么我们采用再先进的算法，效果也好不到哪里去。很多人可能关注不到这一点，但是实际工作中，很大比例指标上不去的情况是因为数据集不干净，所以题主也可以看看自己的数据集是不是有脏数据。</p><p>原始数据准备好以后，即使这时候很干净，也不能保证后面结果就是好的，因为我们为了提升算法的鲁棒性，可能还需要做一些==数据扩增==，而我们的算法工程师如果对任务的了解不够透彻，数据增强也可能会使指标变差。比如我们关注一个物体的颜色信息，但是我们的[数据扩增]里面加了随机颜色变换，那后面的结果肯定会很奇怪。大家可能会感觉很奇怪，怎么可能会出现这种情况，但是不合适的数据增强导致指标差的情况，比比皆是。</p></li><li><p>任务定义好，数据准备好，也就可以出模型或者出算法了。如果选择深度学习，很多的训练技巧还需要去掌握，各种超参的调整，loss的选择，训练时间，训练显存占用的控制，推理计算量，推理时间的控制等等，都需要去考虑。如果是用传统机器学习或者传统图像处理，还需要去考虑手工选取特征，这些特征是不是具有普适性。</p></li><li><p>以上三点做好，基本出来的模型或者算法的指标就有个基本保证，baseline是有了，后面就是迭代优化了。当然怎么快速迭代，怎么加数据更有效也是一个很有技术含量的工作，是无脑添加，见到数据就加；还是有针对性的加，有目的的加，这些都值得仔细去考虑。如果使用传统图像处理算法，还得注意在迭代过程中遇到的新数据，老的特征能不能cover。</p></li></ol><blockquote><p>一个算法的落地就是从需求调研，制定baseline，采集数据，出baseline之后大优化，千万不要急着上头看SOTA论文，没用的。工业界优化最重要的就是：数据增强，中继监督（额外的监督信息），比如你检测任务如果有这个资源加上分割检测一定精度高，知识蒸馏，正负样本平衡的技巧，Multi_source多数据源优化特定badcase。模型转出来后上剪枝，量化。基本上一套下来只要你的模型不要太离谱，数据质量高些，基本上效果是没啥问题的。如果有问题的话，那就加数据。</p></blockquote><hr><h3 id="图像处理的三大任务"><a href="#图像处理的三大任务" class="headerlink" title="图像处理的三大任务"></a>图像处理的三大任务</h3><p>人工智能大概分为两个方向:CV(图像处理)和NLP(自然语言处理)</p><p>图像处理cv方向在图像处理中可分为三大任务,即图像分类,目标检测和图像分割</p><h4 id="1-图像分类"><a href="#1-图像分类" class="headerlink" title="1.图像分类"></a><strong>1.图像分类</strong></h4><p>把多种图像分类识别出来</p><p>最优的代表网络:resnet网络和VGG系列网络</p><p>例如把猫狗进行二分类</p><h4 id="2-目标检测"><a href="#2-目标检测" class="headerlink" title="2.目标检测"></a>2.目标检测</h4><p>把目标图像用回归框框出进行类别识别,对目标检测的网络可以分为两大派:==一次检测和两次检测==</p><p>两次检测的最优的代表网络是faster rcnn系列网络,一次检测的代表网络是yolo系列网络</p><p>一次检测在保证识别准确率的情况下,检测速度相对较快,因此yolo系列的网络用的较多</p><h4 id="3-图像分割"><a href="#3-图像分割" class="headerlink" title="3.图像分割"></a>3.图像分割</h4><p>把目标图像的轮廓分割出来,分为语义分割,实例分割,全景分割</p><h5 id="语义分割"><a href="#语义分割" class="headerlink" title="语义分割"></a>语义分割</h5><p>语义分割 就是需要区分到图中每一点像素点，而不仅仅是矩形框框住了。但是同一物体的不同实例不需要单独分割出来。</p><h5 id="实例分割"><a href="#实例分割" class="headerlink" title="实例分割"></a>实例分割</h5><p>实例分割 就是目标检测和语义分割的结合。相对目标检测的边界框，实例分割可精确到物体的边缘；相对语义分割，实例分割需要标注出图上同一物体的不同个体</p><p>代表网络是<em><strong>mask rcnn</strong></em>网络,既对图像进行目标检测又进行图像分割</p><h5 id="全景分割"><a href="#全景分割" class="headerlink" title="全景分割"></a>全景分割</h5><p>全景分割是语义分割和实例分割的结合。跟实例分割不同的是：实例分割只对图像中的object进行检测，并对检测到的object进行分割，而全景分割是对图中的所有物体包括背景都要进行检测和分割。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经历回顾-221214</title>
      <link href="/2022/12/14/jing-li-hui-gu-221214/"/>
      <url>/2022/12/14/jing-li-hui-gu-221214/</url>
      
        <content type="html"><![CDATA[<p>今天整理一下大学期间参与过的项目，算是在自己还没有参加工作之前记录一下。</p><p>*按照参与程度排序</p><h3 id="一、OCR字符识别"><a href="#一、OCR字符识别" class="headerlink" title="一、OCR字符识别"></a>一、OCR字符识别</h3><p>时间：大二下学期</p><p>使用了easyocr、ocr.pytorch-master、tesseract_ocr_master等等，项目运行结果图已经找不到了。</p><p>这个项目完全是我自己的一个想法，想去自己做一个ocr，经过深入的了解学习，发现要学习机器学习、深度学习，训练模型，觉得自己没有达到开一个模型的能力，于是采用的第三方库进行识别，效果一般。</p><img src="https://gitee.com/sainthood2077/cloudimg/raw/main/images/image-20221214144756227.png" alt="项目文档" style="zoom: 80%;"><p>包括自己去看论文，这个项目虽然没有什么结果，没有去参加比赛，但是收获很大，毕竟是自己愿意去学习、去研究的方向。</p><img src="https://gitee.com/sainthood2077/cloudimg/raw/main/images/image-20221214145518300.png" alt="image-20221214145518300" style="zoom:50%;"><p>在过程中也了解了很多ocr现有的字符识别模型，他们各自的优略</p><img src="https://gitee.com/sainthood2077/cloudimg/raw/main/images/OCR%E8%AF%86%E5%88%AB%E6%A8%A1%E5%9E%8B%E5%AF%B9%E6%AF%94.png" alt="OCR识别模型对比" style="zoom: 40%;"><p>更深入的了解了图像处理二值化、灰度化、图像降噪等等</p><img src="https://gitee.com/sainthood2077/cloudimg/raw/main/images/image-20221214150509578.png" alt="项目策划书" style="zoom:50%;"><h3 id="二、基于Django的员工管理系统"><a href="#二、基于Django的员工管理系统" class="headerlink" title="二、基于Django的员工管理系统"></a>二、基于Django的员工管理系统</h3><p>时间：大四上学期</p><p>说是员工管理系统，其实是为了做毕业设计而学习的一个demo，为了联系django语法，目前还在完善</p><p>实现了基本的增删改查、分页、登陆注册，还需要完善中间件，实现Ajax请求</p><p><video name="录屏演示" src="C:%5CUsers%5Cdell%5CVideos%5C20221214_153659.mp4"></video></p><h3 id="三、Java-web的网上书城"><a href="#三、Java-web的网上书城" class="headerlink" title="三、Java web的网上书城"></a>三、Java web的网上书城</h3><p>时间：大一</p><p>实现了登录、注册、找回密码、信息管理、订单管理等等功能。</p><p><img src="https://gitee.com/sainthood2077/cloudimg/raw/main/images/image-20221214154409524.png" alt="数据表"></p><p><img src="https://gitee.com/sainthood2077/cloudimg/raw/main/images/image-20221214154535536.png" alt="首页"></p><p><img src="https://gitee.com/sainthood2077/cloudimg/raw/main/images/image-20221214154735585.png" alt="商品浏览"></p><p><img src="https://gitee.com/sainthood2077/cloudimg/raw/main/images/image-20221214155442568.png" alt="订单管理-待发货"></p><p><img src="https://gitee.com/sainthood2077/cloudimg/raw/main/images/image-20221214155518964.png" alt="产品预览"></p><h3 id="四、“中华筷箸”文化传承小程序的设计与实现"><a href="#四、“中华筷箸”文化传承小程序的设计与实现" class="headerlink" title="四、“中华筷箸”文化传承小程序的设计与实现"></a>四、“中华筷箸”文化传承小程序的设计与实现</h3><p>时间：大三上</p><p><img src="https://gitee.com/sainthood2077/cloudimg/raw/main/images/2048_164517_ci.png" alt="小程序截图1"></p><p><img src="https://gitee.com/sainthood2077/cloudimg/raw/main/images/2048_164537_ci.png" alt="小程序截图2"></p><p><img src="C:%5CUsers%5Cdell%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20221214164915969.png" alt="后台管理"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 项目回顾 </tag>
            
            <tag> 记录成长 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试真题</title>
      <link href="/2022/11/25/mian-shi-zhen-ti/"/>
      <url>/2022/11/25/mian-shi-zhen-ti/</url>
      
        <content type="html"><![CDATA[<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><ul><li> 列举常见的内置函数</li></ul><table><thead><tr><th></th><th></th><th><strong>内置函数</strong></th><th></th><th></th></tr></thead><tbody><tr><td><a href="http://www.runoob.com/python3/python3-func-number-abs.html">abs()</a></td><td><a href="http://www.runoob.com/python/python-func-dict.html">dict()</a></td><td><a href="http://www.runoob.com/python/python-func-help.html">help()</a></td><td><a href="http://www.runoob.com/python3/python3-func-number-min.html">min()</a></td><td><a href="http://www.runoob.com/python/python-func-setattr.html">setattr()</a></td></tr><tr><td><a href="http://www.runoob.com/python/python-func-all.html">all()</a></td><td><a href="http://www.runoob.com/python/python-func-dir.html">dir()</a></td><td><a href="http://www.runoob.com/python/python-func-hex.html">hex()</a></td><td><a href="http://www.runoob.com/python/python-func-next.html">next()</a></td><td><a href="http://www.runoob.com/python/python-func-slice.html">slice()</a></td></tr><tr><td><a href="http://www.runoob.com/python/python-func-any.html">any()</a></td><td><a href="http://www.runoob.com/python/python-func-divmod.html">divmod()</a></td><td><a href="http://www.runoob.com/python/python-func-id.html">id()</a></td><td>object()</td><td><a href="http://www.runoob.com/python3/python3-func-sorted.html">sorted()</a></td></tr><tr><td><a href="http://www.runoob.com/python3/python3-func-ascii.html">ascii()</a></td><td><a href="http://www.runoob.com/python3/python3-func-enumerate.html">enumerate()</a></td><td><a href="http://www.runoob.com/python/python3-func-input.html">input()</a></td><td><a href="http://www.runoob.com/python/python-func-oct.html">oct()</a></td><td><a href="http://www.runoob.com/python/python-func-staticmethod.html">staticmethod()</a></td></tr><tr><td><a href="http://www.runoob.com/python/python-func-bin.html">bin()</a></td><td><a href="http://www.runoob.com/python/python-func-eval.html">eval()</a></td><td><a href="http://www.runoob.com/python/python-func-int.html">int()</a></td><td><a href="http://www.runoob.com/python3/python3-func-open.html">open()</a></td><td><a href="http://www.runoob.com/python/python-func-str.html">str()</a></td></tr><tr><td><a href="http://www.runoob.com/python/python-func-bool.html">bool()</a></td><td><a href="http://www.runoob.com/python3/python3-func-exec.html">exec()</a></td><td><a href="http://www.runoob.com/python/python-func-isinstance.html">isinstance()</a></td><td><a href="http://www.runoob.com/python/python-func-ord.html">ord()</a></td><td><a href="http://www.runoob.com/python/python-func-sum.html">sum()</a></td></tr><tr><td><a href="http://www.runoob.com/python/python-func-bytearray.html">bytearray()</a></td><td><a href="http://www.runoob.com/python3/python3-func-filter.html">filter()</a></td><td><a href="http://www.runoob.com/python/python-func-issubclass.html">issubclass()</a></td><td><a href="http://www.runoob.com/python3/python3-func-number-pow.html">pow()</a></td><td><a href="http://www.runoob.com/python/python-func-super.html">super()</a></td></tr><tr><td><a href="http://www.runoob.com/python3/python3-func-bytes.html">bytes()</a></td><td><a href="http://www.runoob.com/python/python-func-float.html">float()</a></td><td><a href="http://www.runoob.com/python/python-func-iter.html">iter()</a></td><td><a href="http://www.runoob.com/python/python-func-print.html">print()</a></td><td><a href="http://www.runoob.com/python3/python3-func-tuple.html">tuple()</a></td></tr><tr><td><a href="http://www.runoob.com/python/python-func-callable.html">callable()</a></td><td><a href="http://www.runoob.com/python/att-string-format.html">format()</a></td><td><a href="http://www.runoob.com/python3/python3-string-len.html">len()</a></td><td><a href="http://www.runoob.com/python/python-func-property.html">property()</a></td><td><a href="http://www.runoob.com/python/python-func-type.html">type()</a></td></tr><tr><td><a href="http://www.runoob.com/python/python-func-chr.html">chr()</a></td><td><a href="http://www.runoob.com/python/python-func-frozenset.html">frozenset()</a></td><td><a href="http://www.runoob.com/python3/python3-att-list-list.html">list()</a></td><td><a href="http://www.runoob.com/python3/python3-func-range.html">range()</a></td><td><a href="http://www.runoob.com/python/python-func-vars.html">vars()</a></td></tr><tr><td><a href="http://www.runoob.com/python/python-func-classmethod.html">classmethod()</a></td><td><a href="http://www.runoob.com/python/python-func-getattr.html">getattr()</a></td><td><a href="http://www.runoob.com/python/python-func-locals.html">locals()</a></td><td><a href="http://www.runoob.com/python/python-func-repr.html">repr()</a></td><td><a href="http://www.runoob.com/python3/python3-func-zip.html">zip()</a></td></tr><tr><td><a href="http://www.runoob.com/python/python-func-compile.html">compile()</a></td><td><a href="http://www.runoob.com/python/python-func-globals.html">globals()</a></td><td><a href="http://www.runoob.com/python/python-func-map.html">map()</a></td><td><a href="http://www.runoob.com/python3/python3-func-reversed.html">reversed()</a></td><td><a href="http://www.runoob.com/python/python-func-__import__.html"><strong>import</strong>()</a></td></tr><tr><td><a href="http://www.runoob.com/python/python-func-complex.html">complex()</a></td><td><a href="http://www.runoob.com/python/python-func-hasattr.html">hasattr()</a></td><td><a href="http://www.runoob.com/python3/python3-func-number-max.html">max()</a></td><td><a href="http://www.runoob.com/python3/python3-func-number-round.html">round()</a></td><td></td></tr><tr><td><a href="http://www.runoob.com/python/python-func-delattr.html">delattr()</a></td><td><a href="http://www.runoob.com/python/python-func-hash.html">hash()</a></td><td><a href="http://www.runoob.com/python/python-func-memoryview.html">memoryview()</a></td><td>set()</td><td></td></tr></tbody></table><ul><li>简述yield和yeild from关键字</li></ul><p><a href="https://www.cnblogs.com/zhuifeng-mayi/p/9248641.html">60、简述 yield和yield from关键字。-  追风的小蚂蚁-  博客园 (cnblogs.com)</a></p><ul><li>常用模块都有哪些，列举8个</li></ul><blockquote><p>time模块datetime模块random 模块os 模块sys 模块json 和 pickle 模块hashlib和hmac 模块logging 模块numpy 模块pandas 模块matplotlib 模块re 模块typing 模块collections 模块pathlib 模块shutil 模块xml 模块subprocess 模块configparser模块math模块</p></blockquote><ul><li>序列化与反序列化模块</li></ul><blockquote><p>json模块和pickle模块是用来序列化和反序列化数据的模块。</p><p>序列化指的是把内存的数据类型转换成一种特定的格式的内容，该格式的内容可用于存储或者传输给其他平台(其他编程语言)使用，反序列化就是将其他平台上的数据转换成python能够识别的数据格式。</p><p>序列化：</p><p>内存中的数据类型—-》序列化—-》特定的格式（json/pickle格式）</p><p>反序列化：</p><p>内存中的数据类型《—-反序列化《—-特定的格式（json/pickle格式）</p><p>数据进行序列化有两种用途：</p><p>其一，可以持久保存程序运行过程中产生的数据，将数据写到磁盘中。</p><p>其二，序列化之后，不仅可以把序列化后的内容写入磁盘，还可以通过网络传输到别的机器上，如果收发的双方约定好使用一种序列化的格式，那么便打破了平台/语言差异化带来的限制，实现了跨平台数据交互。</p><p>序列化和反序列化的操作可以借助json和pickle模块。</p></blockquote><ul><li><p> 列举3条常见异常</p></li><li><p> 列举三条以上PEP8编码规范</p></li><li><p> json序列化时，可以处理的数据类型有哪些？如何保持原字典的顺序？</p></li><li><p> @classmethod,@staticmethod,@property含义及用法</p></li><li><p> 写一个可以给定出错重试次数的装饰器，用来处理HTTP超时等</p></li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">getresponse</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">:</span>    r<span class="token operator">=</span>resquests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">[</span>www<span class="token punctuation">.</span>baidu<span class="token punctuation">.</span>com<span class="token punctuation">]</span><span class="token punctuation">(</span>http<span class="token punctuation">:</span><span class="token operator">//</span>www<span class="token punctuation">.</span>baidu<span class="token punctuation">.</span>com<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> r<span class="token punctuation">.</span>content</code></pre><ul><li><p> 简述python的垃圾回收机制</p></li><li><p> HTTP协议中，Cookie和Session的区别是什么？GET和POST分别是做什么，你还知道其他的方法吗</p></li><li><p> Python中有哪些方法可以实现并行，他们分别适用于什么场景？如果Django的web服务器想要提高并发性能，有哪些方法？</p></li><li><p> Python中的装饰器是什么？@classmethod,@staticmethod,@property这些装饰器的用途分别是什么？请实现一个简单的装饰器，实现运行函数的过程中打印出函数执行时间</p></li><li><p> 简要描述数组、链表、队列、堆栈的区别。如果我已经利用Python实现了一个堆栈的类Stack，是否可以以此为基础实现一个队列？请写一段代码实现</p></li><li><p> 写出你知道的排序算法，并使用Python实现一种排序算法，对0-100的整数列表进行排序</p></li><li><p> 什么是可变于不可变类型</p></li><li><p> 浅拷贝和深拷贝的实现方式、区别：</p></li><li><p> <strong>new</strong>()与__init__()的区别：</p></li><li><p> 你知道几种设计模式</p></li><li><p> 编码和解码你了解过么</p></li><li><p> 什么是装饰器：如果想在函数之后进行装饰，应该怎么做</p></li><li><p> 手写个使用装饰器实现的单例模式</p></li><li><p> 手写正则邮箱地址</p></li><li><p> 进程通信的方式有几种</p></li><li><p> range和xrange的区别</p></li><li><p> 手写，用一行python写出1+2+3+…+10**8</p></li><li><p> TCP/IP分别在模型的哪一层</p></li><li><p> socket长连接是什么意思</p></li><li><p> http一次连接的全过程：你来说下从用户发起的request——到用户的response</p></li><li><p> 线程和进程的联系与区别</p></li><li><p> 死锁的条件有哪些</p></li><li><p> list和tuple区别有哪些</p></li><li><p> set类的特点有哪些</p></li><li><p> GIL是什么？它对于Python多线程编程有什么影响</p></li><li><p> 函数参数*args和**kwargs分别是什么意思</p></li><li><p> numbers是一个列表，元素都是整型，请写出代码求numbers中的所有值的和</p></li><li><p> 请为这个函数写一个装饰器，使用之后，在函数调用前和后分别输出log到stderr（简单的print log即可）</p></li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> foo（）：<span class="token keyword">print</span> （“Function foo”）</code></pre><ul><li><p> 函数bar()可能会抛出一个自定义的异常CustomError，请写代码实现如下功能：如果bar()抛出了CustomError,打印“custom error”；否则打印“success”</p></li><li><p> 在定义类的时候，@property装饰器的作用是什么？</p></li><li><p> 请描述一下mock库（python2.7单独提供），或者unittest.mock库（python3.3开始加入标准库）的作用</p></li><li><p> 如果你使用过以下几个工具，请描述一下他们的作用：pip，virtualenv，tox</p></li><li><p>函数bisect_left（a，x）的功能如下，参数a是一个按照升序排列的list（list中的元素类型是整型）参数x是一个整型，函数bisect_left（a，x）返回函数x在a中的最左侧的插入位置，插入x之后，数组a保持有序。请基于bisect_left（a，x）函数，实现index（a，x）函数，该函数返回x在a中的最小的索引，如果x在a中不存在，请抛出valueError异常</p><p>def index（a，x）：</p></li><li><p> 浮点数比较，double a，b；a=0.1*3；b=0.1+0.1+0.1，a==b吗？为什么？如何比较浮点数的大小？</p></li><li><p> 你知道汉字的编码方式有几种？在HTTP GET请求中，一般如何像后端服务器传递汉字信息比较好？</p></li><li><p> 简单描述几种你熟悉的设计模式，以及适用的场景</p></li><li><p> 数字序列3，5，37，121，n，2037中，n该为什么，为什么？</p></li><li><p> 用自己熟悉的语言编程实现：给定一个存放整数的数组，重新排列数组使得数组左边为奇数，右边为偶数</p></li><li><p> 用自己熟悉的语言编程实现：给定一个字符串，满足正则表达式[a-zA-Z]+，打印这个字符串的全排列，结果顺序不限，例如，输入为abc，输出为abc acb bac bca cba cab</p></li><li><p> 无需编码，说明需求：犹豫上述题目中的字符串可能含有重复的字符，你能否想出尽量省时间和空间的方式，让输出的全排列没有重复？</p></li><li><p>编程：输入一个字符串，输出该字符串中字符的所有组合</p><p>例如：输入字符串“123”，则输出为1、2、3、12、23、13、123（不考虑顺序12、21等价）</p></li><li><p> 谈谈你知道的python web框架</p></li><li><p> 编程：使用python实现数据库的student表中提取的数据写入db.txt</p></li><li><p> 实现斐波那契数列（使用递归）</p></li><li><p> 简述left join和right join的区别</p></li><li><p> 描述一下MVC开发模式</p></li><li><p> L.简述HTTP协议下，一个HTTP请求的数据结构。简述HTTP与HTTPS协议的差异。</p></li><li><p> Python2和Python3的区别。</p></li><li><p> 影响服务器请求QBS的核心问题有哪些？</p></li><li><p> Python如何处理一秒钟500次的日志写操作？</p></li><li><p> 一张mysql数据表，每天300万左右的数据增长量，怎么保证一年后表查询的稳定？</p></li><li><p> 简述Python import的执行流程。</p></li><li><p> 列表[1,2,3,4,5]，请使用map（）图数输出[1,4,9,16,25]，并使用列表推导式提取出大于10的数，最终输出[16,25]</p></li><li><p> 正则匹配不是以4和7结尾的手机号</p></li><li><p> 列出几种魔法方法并简要介绍用途</p></li><li><p> 举例说明异常模块中try except else finally的相关意义</p></li><li><p> 如何用Python别除一个文件？：</p></li><li><p>获取a和b的交集与差集：</p></li></ul><p>a=[21,22,55]</p><p>B=[21,55.77]</p><ul><li><p>python如何捕获异常（输出异常）：</p></li><li><p>写一段代码用json数据的处理方式获取{“person”:[{“name”:”yu”,”age”:”23”),{“name”:”zhang”,”age”:”34”}]}这一段json中第一个人的名字</p></li><li><p>用正则匹配h5内的img标签内src内容：</p></li></ul><pre class=" language-html"><code class="language-html">h5="<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span><span class="token punctuation">></span></span>name<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://baidu.com/sss/aaa.ipg<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>"</code></pre><ul><li><p> 创建两个线程，其中一个输出1-52，另外一个输出A-Z.输出格式要求：12A 34B 56C 78D</p></li><li><p> 一只青蛙一次可以跳上1级台阶，也可以跳上2级，一共10级台阶，一共有多少种跳法</p></li></ul><p><a href="https://www.cnblogs.com/Chen-K/p/11623084.html">Python算法题（一）——青蛙跳台阶-  陈康、-  博客园 (cnblogs.com)</a></p><ul><li><p>简述python异步调用的原理或过程，或写出示例代码</p></li><li><p>python中的某个变量值为None,如果存储到mysql数据库中会是什么结果？</p></li><li><p>实现一个装饰器，打印函数的参数</p></li><li><p>打印目录（包括子目录）下面的所有文件的绝对路径</p></li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">print_dir_contents</span><span class="token punctuation">(</span>filepath<span class="token punctuation">)</span><span class="token punctuation">:</span></code></pre><ul><li><p> 写代码去除html文件中的标签</p></li><li><p>  给你一个字符串，比如”abc’,请打印出该字符串的所有排列组台；以“abc”为例，输出的结果应该是：abc,acb,bac,bca,cab,cba,实际的字将串长度超过100个字符。</p></li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> itertools<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">Permutation</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ss<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> ss <span class="token operator">==</span> <span class="token string">""</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    lit <span class="token operator">=</span> list<span class="token punctuation">(</span>itertools<span class="token punctuation">.</span>permutations<span class="token punctuation">(</span>list<span class="token punctuation">(</span>ss<span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>ss<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#第一个参数是列表的形式，是将列表的元素排列，第二个参数是将排列的数几个一组分好。最后的list是将小列表组成一个大列表，小列表作为大列表的元素</span>    <span class="token keyword">for</span> elem <span class="token keyword">in</span> lit<span class="token punctuation">:</span>        x <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>        <span class="token keyword">if</span> x <span class="token operator">not</span> <span class="token keyword">in</span> result<span class="token punctuation">:</span>            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">return</span> result</code></pre><ul><li> 写出下面代码的输结果</li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span>t<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  t<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">)</span>  <span class="token keyword">print</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  func<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>func<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#结果：</span><span class="token comment" spellcheck="true">#['x']</span><span class="token comment" spellcheck="true">#['x', 'x']</span><span class="token comment" spellcheck="true">#['x', 'x', 'x']</span><span class="token comment" spellcheck="true">#['x']</span><span class="token comment" spellcheck="true">#['x']</span><span class="token comment" spellcheck="true">#['x']</span></code></pre><ul><li><p> 列举http协议头部字段，并说明每个字段的主要作用</p></li><li><p> 解释堆内存和栈内存的区别</p></li><li><p> 请用最简洁的代码，实现如下功能：将元素类型均为it的某个list里面数值大于100的元素输出到另外一个list,同时，这些元素在新的ist里面从大到小排序</p></li></ul><pre class=" language-python"><code class="language-python">List <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">101</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">130</span><span class="token punctuation">,</span> <span class="token number">422</span><span class="token punctuation">]</span>new <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> List<span class="token punctuation">:</span>  <span class="token keyword">if</span> i <span class="token operator">></span> <span class="token number">100</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    new<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>new<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>reverse<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>new<span class="token punctuation">)</span></code></pre><ul><li> Python不使用int()函数把字符串转换为数字</li></ul><p>[Python不使用int()函数把字符串转换为数字-  枫飞飞-  博客园 (cnblogs.com)](<a href="https://www.cnblogs.com/fengff/p/10483737.html#:~:text=Python%E4%B8%8D%E4%BD%BF%E7%94%A8int">https://www.cnblogs.com/fengff/p/10483737.html#:~:text=Python不使用int</a> ()函数把字符串转换为数字 1 方法一：利用str函数 2,方法二：利用ord函数 3 方法三：利用eval函数 4 例题如下：)</p><ul><li><p> List=[-2,1,3,-6],如何实现以绝对值大小从小到大将List中内容排序。</p></li><li><p> 列表的sort方法和sorted的区别是什么？</p></li><li><p>有一段英文文章保存在a.txt中，请用python实现统计这个篇文章中每个单词的出现频率，并返回出现频率最高的前10个单词及其出现的次数（只考虑空格，标点符号可忽略）</p><p>追加需求，引号内元素算作一个单词，如何实现？</p></li><li><p> python中的变量作用域（变量查找顺序）</p></li><li><p> 描述Python GIL的概念，以及它对python多线程的影响？编写一个多线程抓取网页的程序，并阐明多线程抓取程序是否可比单线程性能有提升，并解释原因。</p></li><li><p>  Python中如何动态获取和设置对象的属性</p></li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Parens</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>  x <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">class</span> <span class="token class-name">Children1</span><span class="token punctuation">(</span>Parens<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">pass</span><span class="token keyword">class</span> <span class="token class-name">Children2</span><span class="token punctuation">(</span>Parens<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">pass</span> <span class="token keyword">print</span><span class="token punctuation">(</span>Parens<span class="token punctuation">.</span>x<span class="token punctuation">,</span> Children1<span class="token punctuation">.</span>x<span class="token punctuation">,</span> Children2<span class="token punctuation">.</span>x<span class="token punctuation">)</span>Children1<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">2</span><span class="token keyword">print</span><span class="token punctuation">(</span>Parens<span class="token punctuation">.</span>x<span class="token punctuation">,</span> Children1<span class="token punctuation">.</span>x<span class="token punctuation">,</span> Children2<span class="token punctuation">.</span>x<span class="token punctuation">)</span>Children2<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">2</span><span class="token keyword">print</span><span class="token punctuation">(</span>Parens<span class="token punctuation">.</span>x<span class="token punctuation">,</span> Children1<span class="token punctuation">.</span>x<span class="token punctuation">,</span> Children2<span class="token punctuation">.</span>x<span class="token punctuation">)</span>Parens<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">3</span><span class="token keyword">print</span><span class="token punctuation">(</span>Parens<span class="token punctuation">.</span>x<span class="token punctuation">,</span> Children1<span class="token punctuation">.</span>x<span class="token punctuation">,</span> Children2<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#结果是：</span><span class="token comment" spellcheck="true">#1 1 1</span><span class="token comment" spellcheck="true">#1 2 1</span><span class="token comment" spellcheck="true">#1 2 2</span><span class="token comment" spellcheck="true">#3 2 3</span></code></pre><ul><li><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">multipliers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span>i<span class="token operator">*</span>x <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">[</span>m<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">for</span> m <span class="token keyword">in</span> multipliers<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre></li><li><p> 列表去重（不迪用set,用基本的方法实现）：set=9,4,2,5,8,4,5,3)</p></li></ul><pre class=" language-python"><code class="language-python">li<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token keyword">from</span> collections <span class="token keyword">import</span> Counter<span class="token keyword">print</span><span class="token punctuation">(</span>list<span class="token punctuation">(</span>Counter<span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><ul><li><p> 单例模式实现</p></li><li><p> is和=的区别</p></li></ul><blockquote><ul><li><p>is比较的是两个实例对象是不是完全相同，它们是不是同一个对象，占用的内存地址是否相同。莱布尼茨说过：“世界上没有两片完全相同的叶子”，这个$正是这样的比较，比较是不是同一片叶子（即比较的id是否相同，这id类似于人的身份证标识）。</p></li><li><p>==比较的是两个对象的内容是否相等，即内存地址可以不一样，内容一样就可以了。这里比较的并非是同一片叶子，可能叶子的种类或者脉络相同就可以了。默认会调用对象的__eq__()方法。</p></li></ul></blockquote><ul><li><p> 什么是lambda函数？它有什么好处？</p></li><li><p> 用过的标准包以及第三方包(os以及SyS)</p></li><li><p> range以及xrange有什么区别；</p></li><li><p> re中的match以及search有什么区别；</p></li><li><p> 分别写-个或多个关于filter()、reduce()、map()的使用实例</p></li><li><p> Python里面如何实现tuple和list的转换？</p></li></ul><p>请写出一段Python代码实现删除一个list里面的重复元素</p><p>Python中pass语句的作用是什么？</p><ul><li><p> re模块中的split(),sub(),subn()如何使用？</p></li><li><p> python中如何产生随机数</p></li><li><p> 如何写python的单元测试？请给出具体的例子</p></li><li><p> repr() 方法可以将读取到的格式字符，比如换行符、制表符，转化为其相应的转义字符</p></li><li><p> sort 与 sorted 区别：</p></li></ul><p>sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。</p><p>list 的 sort 方法返回的是对已经存在的列表进行操作，无返回值，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。</p><ul><li><p>把”<a href="http://www.baidu.com&amp;/#39;,%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2moc.udiab.www%E3%80%82">www.baidu.com',反转字符串moc.udiab.www。</a></p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">reservestr</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> x<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span></code></pre></li><li><p> 写一个函数单链表查找链表中间节点。</p></li><li><p> 日志脚本获取题目</p></li></ul><p>假如日志文件有5种类型(error、debug、info、exception、er),怎么样写一个脚本让他们归类统计错误类型的次数？</p><p>提示：日志文件是一个效文件，里面成千上万行数据。里面内容如下：</p><p>Error:abd…</p><p>Debug:gfgfggggggg</p><p>…</p><p>Info:134445dkddkk</p><p>提示：方法有很多，关键地方是怎么样转化字符流，读取，判断、统计带上面五种类型的日</p><p>志信息条数。</p><ul><li><p> 如何判断字符串A里面是否包含字符串B里面所有的字符</p></li><li><p> 给一个字符串和一个偏移量，让这个字符串按照偏移量的值把最后几个字符依次移到最前面</p></li><li><p> 判断一个数字字符串是否是IP地址，以及有哪几种可能的组合</p></li><li><p> Python2和Python3的区别</p></li><li><p> 如果把一个项目从Python2迁移到Python3</p></li><li><p> Python 中的__new__和__init__的区别</p></li></ul><p><a href="https://www.cnblogs.com/shenxiaolin/p/9307496.html">Python 中的__new__和__init__的区别-  CuriousZero-  博客园 (cnblogs.com)</a></p><ul><li>  合并两个有序的数组，数组都是非递减的，合并后的数组依然有序</li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span><span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>nums1<span class="token punctuation">,</span>m<span class="token punctuation">,</span>nums2<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>‘’’<span class="token punctuation">:</span>type nums1<span class="token punctuation">:</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>type m<span class="token punctuation">:</span>inttype nums2<span class="token punctuation">:</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>type n<span class="token punctuation">:</span>intrtype<span class="token punctuation">:</span>void Do <span class="token operator">not</span> <span class="token keyword">return</span> anything<span class="token punctuation">,</span>modify nums1 <span class="token keyword">in</span><span class="token operator">-</span>place instead<span class="token punctuation">.</span>‘’’</code></pre><ul><li> 求n阶乘结果末尾连续0的个数，如5！=120，0的个数为1</li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span><span class="token keyword">def</span> <span class="token function">trailingZeroes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>‘’’<span class="token punctuation">:</span>type n<span class="token punctuation">:</span>int<span class="token punctuation">:</span>rtype<span class="token punctuation">:</span>int‘’’</code></pre><ul><li> 反转数字，例子：输入123，输出321；输入-123，输出-321；输入1032100，输出12301</li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span><span class="token keyword">def</span> <span class="token function">reverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>‘’‘<span class="token punctuation">:</span>type x<span class="token punctuation">:</span>int<span class="token punctuation">:</span>rtype<span class="token punctuation">:</span>int‘‘’</code></pre><ul><li> 求股票最大收益，给出一个数组，每个元素代表股票价格。设计一个算法，你可以多次买入和多次卖出，使得你的收益最大。算出最大收益。</li></ul><p>class Solution:</p><p>​    def maxProfit(self,prices):</p><blockquote><ul><li>垃圾回收</li></ul><p>Python的GC模块主要运用了引用计数来跟踪和回收垃圾。在引用计数的基础上，还可以通过“标记一清除”解决容器对象可能产生的循环引用的问题。通过分代回收以空间换取时间进一步提高垃圾回收的效率。</p><ul><li>引用计数</li></ul><p>原理：当一个对象的引用被创建或者复制时，对象的引用计数加1；当一个对象的引用被销毁时，对象的引用计数减1，当对象的引用计数减少为0时，就意味着对象已经再没有被使用了，可以将其内存释放掉。</p><p>优点：引用计数有一个很大的优点，即实时性，任何内存，一旦没有指向它的引用，就会被立即回收，而其他的垃圾收集技术必须在某种特殊条件下才能进行无效内存的回收。</p></blockquote><blockquote><p>首先介绍你做过的项目</p><p>1、d模块批量导入数据时，数据量很大，超过10M怎么处理？有看过导入后的数据吗？</p><p>(回答不会)</p><p>2、什么情况下需要用到缓存？你在什么地方用到过？+</p><p>3、你用过什么设计模式？</p><p>4、路飞中用的是什么视图(CVB)？说说在什么情况下用类或煮面向对象？</p><p>5、你在django中用原生sg还是ORM？’</p><p>6、</p><pre class=" language-python"><code class="language-python">users<span class="token operator">=</span>User<span class="token punctuation">.</span>obiects<span class="token punctuation">.</span>a11<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> user <span class="token keyword">in</span> users<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>info<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#info和user表是一对一</span><span class="token comment" spellcheck="true">#如何进行优化查询？</span></code></pre><p>7、通过什么方式自学的？遇到问题怎么办？有和产品经理对接过吗？</p><p>8、权限按钮级别是如何实现的？考虑下如何实现到单条信息级别？：</p><p>9、有在github上面看过源码和文档吗？看过django文档吗（傻不拉几的我说没有)</p><p>10、最近在学什么新技术？</p><p>11、如何提高数据库查询效率？</p><p>12、什么情况下使用消息队列？</p><p>13、路飞项目过程中是如何和前端配合的？</p><p>14、项目是自己的独立开发的吗？</p></blockquote><ul><li><p> 请列举你所用过的Pyon代码检测工具</p></li><li><p> 简述Python垃圾回收机制及如何解决循环引用</p></li><li><p> 简述Python2中什么样的情况下会触发UnicodeDscodeError</p></li><li><p> 请简述标准库中functoo1s,partial的实现思路</p></li><li><p> 请简述标准库中funtools.wraps的作用</p></li><li><p> 简述Python上下文管理器的原理，并用上下文管理器简单实现将“hello world”写入文件的功能</p></li><li><p> 简述MyISM和InnoDB的特点</p></li><li><p> 简述一致性哈希原理和它要解决的问题</p></li><li><p> 简述C10K问题和解决方案</p></li><li><p> 什么是GIL</p></li><li><p> serch（）和mathch（）的区别</p></li><li><p> 简述迭代器和生成器以及它们之间的区别</p></li><li><p> 什么是协程？py的协程是如何实现的</p></li><li><p> 什么是装饰器？请用装饰器实现singleton</p></li><li><p> 请使用python实现快速排序</p></li><li><p>简述select和epo11的原理和区别</p></li><li><p>简达python的垃圾回收机制</p></li><li><p> 写一个简单的Python socket编程</p></li><li><p> 有这样一个文本文件，他的路径为baseDir,.他的名字test.txt,要求用with方式进行打开，并打印每一行文本，并要求文件路径的考虑跨平台问题</p></li><li><p> 用最简洁的方式初始化一个变量foo=[4，16，36，64，100]</p></li><li><p> 使用生成器编写fib函数，函数声名为fib（max）传入一个参数max值，使得该函数可以这样调用</p></li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">for</span> I <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0.100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span> fib<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#并产生如下结果（斐波那契(Fibonacc)数列），1，1，2，3，5，8，13，21……</span></code></pre><ul><li><p> 手写s=【1，2，3】w=[4,5,6] z=[(1,4),(2,5),{3,6}] 这个实现</p></li><li><p> 手写socket服务客户端与客户</p></li><li><p> 手写sql 分组计数</p></li><li><p> 如何进行缓存 我有1kw的数据，想在redis里面缓存了最火的20w条数据</p></li><li><p> 多线程与多进程的应用场景  </p></li><li><p> 有了全局锁(GIL)为什么还要LOCK？</p></li><li><p> 牵涉了粘包问题你怎么实现的 8.基本的linux命令</p></li><li><p> git的基本命令 10.你用python的哪些框架</p></li><li><p> int，flood，str，tuple，list，set，dict，前面这些类型哪些可以做dict的key，哪些可以做value</p></li><li><p> 写出结果[1，4，9，16，25，…，100]的列表推导式</p></li><li><p> 使用python实现快排</p></li><li><p> 广度优先，深度优先，遍历二叉树</p></li><li><p> 实现一段代码，功能是将这段代码打印出来</p></li></ul><blockquote><p>最开始问的项目</p><p>  然后主要问了redis,项目中怎么用redis的,Django-redis和redis你用哪种,区别</p><p>  怎么处理高并发</p><p>  怎么解决沾包</p><p>  TCP和udp的区别,简单说一下HTTP</p><p>  输入一个url到看到页面经历了啥</p><p>  RestfulAPI的规范,说完叫我说了一下常见的状态码</p><p>  看过Django源码吗？我跟他说了session 和admin的源码</p><p>  你了解服务器吗 Nginx和Apache,你选哪一个,区别</p><p>  我们发送get请求如何不使用缓存,从数据库里面取东西</p><p>  什么是二叉树，完全二叉树</p><p>  hash表的去重</p><p>  你平时遇到bug是怎么解决的,喜欢看什么技术网站,我想不起来,我说了restframework和RbbitMq和falsk的英文文档</p><p>  数据库的优化</p><p>  用过爬虫吗,怎么爬取谷歌浏览器上的数据,我回道的不太好,他跟我说怎么不考虑vpn因为中国上不了谷歌</p><p>  问了docker,我说我不会,面完以后叫我手写代码</p><p>  1.给了一个需求,原材料,菜谱和菜，叫我实现Django的models设计,然后在views中写出他提供的要求,返回数据</p><p>  2.给定一个随机数组,随便输入一个数K,找出这个数组中低k大的数</p><p>   我用快排写了以后,他说时间复杂度高了,重新考虑一下时间复杂度为n的,</p><p>   letcode <a href="https://leetcode.com/problems/kth-largest-element-in-an-array/description/">https://leetcode.com/problems/kth-largest-element-in-an-array/description/</a></p><p>  3.不好描述 是letcode91题<a href="https://leetcode.com/problems/decode-ways/description/">https://leetcode.com/problems/decode-ways/description/</a></p><p><a href="http://www.cnblogs.com/skiler/category/1008825.html">http://www.cnblogs.com/skiler/category/1008825.html</a></p><ul><li> “””以a、b为实验对象，求a、b的交集”””</li></ul><p>a = [5, 6, 7, 8, 9]</p><p>b = [4, 6, 7, 8, 10]</p><p>print(set(a).intersection(set(b)))</p><p>a = {5, 6, 7, 8, 9}</p><p>b = {4, 6, 7, 8, 10}</p><p>print(a.intersection(b))</p><p>“””以a、b、c为实验对象，求a、b、c的并集”””</p><p>a = [0,1,2,3,4]</p><p>b = [0,2,6]</p><p>c = [-1,2,5,8]</p><p>r = list(set(a).union(b,c)) # 求多个list的并集</p><p>print(‘r- -&gt;’, r)  # 输出：r- -&gt; [0, 1, 2, 3, 4, 5, 6, 8,- 1]”””</p><p>“””以a、b、c为实验对象，求 a 中有，但 b 和 c 都没有的元素的并集”””</p><p>a = [0,1,2,3,4]</p><p>b = [0,2,6]</p><p>c = [-1,2,5,8]</p><p>r = list(set(a).difference(b,c)) # 求特定1个list(a)中有，其他list(b、c)都没有的元素”””</p><p>print(‘r- -&gt;’, r)  # 输出：r- -&gt; [1, 3, 4]”””</p><p>“””以a、b、c为实验对象，求在多个list中只出现过1次的元素组成的集合”””</p><p>a = [0,1,2,3,4]</p><p>b = [0,2,6]</p><p>c = [-1,2,5,8]</p><p>“””方法1:多次使用 symmetric_difference 方法-  不推荐使用，因为若涉及更多list，运算较复杂””” </p><p>#即求a、b、c中元素只出现过1次的集合，结果应该为 [-1,1,2,3,4,5,6,8]</p><p>#注意：symmetric_difference的参数只能有1个，因此可以多次使用该方法，得到结果</p><p>u_abc = list(set(a).union(b,c)) # 求a、b、c的并集</p><p>d_ab = list(set(a).intersection(b)) # 求a、b的交集</p><p>d_bc = list(set(b).intersection(c)) # 求b、c的交集</p><p>d_ac = list(set(a).intersection(c)) # 求a、c的交集</p><p>r1 = list(set(u_abc).difference(d_ab,d_bc,d_ac)) # 求b中有而a中没有的元素</p><p>print(‘r1- -&gt;’, r1)  # 输出：r1- -&gt; [1, 3, 4, 5, 6, 8,- 1]</p><p>“””方法2：使用pandas的value_counts，获取只出现过1次的元素，即获取 values_counts == 1 的元素即可”””</p><p>import pandas as pd</p><p>import numpy as np</p><p>df_np = np.array((a+b+c)) # 将3个list合并在一起，形成数组</p><p>df_count = pd.Series(df_np).value_counts() # 获取每个元素出现的次数</p><p>r2 = list(df_count[df_count == 1].index) # 获取在3个list中只出现过1次的元素</p><p>r2.sort(reverse=False) # 对r2进行排序，方便观察结果</p><p>print(‘r2- -&gt;’, r2) # 输出：r2- -&gt; [-1, 1, 3, 4, 5, 6, 8]</p></blockquote><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> os  <span class="token comment" spellcheck="true"># 第一种深度优先，即先遍历当前目录下的第一个目录里面的第一个目录，以此类推，然后再逐层向上遍历。代码如下d</span>ef gci<span class="token punctuation">(</span>filepath<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#遍历filepath下所有文件，包括子目录 </span>    files <span class="token operator">=</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>filepath<span class="token punctuation">)</span>    <span class="token keyword">for</span> fi <span class="token keyword">in</span> files<span class="token punctuation">:</span>        fi_d <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>filepath<span class="token punctuation">,</span>fi<span class="token punctuation">)</span>        <span class="token keyword">if</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>isdir<span class="token punctuation">(</span>fi_d<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>filepath<span class="token punctuation">,</span> fi_d<span class="token punctuation">)</span><span class="token punctuation">)</span>            gci<span class="token punctuation">(</span>fi_d<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>filepath<span class="token punctuation">,</span>fi_d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#递归遍历/root目录下所有文件</span>gci<span class="token punctuation">(</span><span class="token string">'f:\\test'</span><span class="token punctuation">)</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 第二种广度优先，是先把当前目录下的所有文件文件夹打印出来，再分别进每一个文件夹打印相应的文件文件夹，再一次类推，逐层往下。代码如下</span><span class="token keyword">import</span> os<span class="token punctuation">.</span>pathrootdir <span class="token operator">=</span> <span class="token string">'f:\\test'</span>  <span class="token comment" spellcheck="true"># 指明被遍历的文件夹</span><span class="token keyword">def</span> <span class="token function">gci</span><span class="token punctuation">(</span>rootdir<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> parent<span class="token punctuation">,</span> dirnames<span class="token punctuation">,</span> filenames <span class="token keyword">in</span> os<span class="token punctuation">.</span>walk<span class="token punctuation">(</span>rootdir<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 三个参数：分别返回1.父目录 2.所有文件夹名字（不含路径） 3.所有文件名字</span>        <span class="token keyword">for</span> dirname <span class="token keyword">in</span> dirnames<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 输出文件夹信息</span>            <span class="token comment" spellcheck="true"># print("parent is:" + parent)</span>            <span class="token comment" spellcheck="true"># print("dirname is:" + dirname)</span>            <span class="token comment" spellcheck="true"># print("the full name of the file is:" + os.path.join(parent, dirname)) # 输出文件夹路径信息</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>parent<span class="token punctuation">,</span> dirname<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出文件夹路径信息</span>    <span class="token keyword">for</span> filename <span class="token keyword">in</span> filenames<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 输出文件信息</span>        <span class="token comment" spellcheck="true"># print("parent is:" + parent)</span>        <span class="token comment" spellcheck="true"># print("filename is:" + filename)</span>        <span class="token comment" spellcheck="true"># print("the full name of the file is:" + os.path.join(parent, filename)) # 输出文件路径信息</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>parent<span class="token punctuation">,</span> filename<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出文件路径信息</span>gci<span class="token punctuation">(</span>rootdir<span class="token punctuation">)</span></code></pre><ul><li><p> 什么是lamdba函数？她有什么好处</p></li><li><p> 一轮技术面：</p></li><li><p>一个文件读取内部文件，拿到频率前十，不区分大小写.</p></li><li><p>建立一个django.项目，读取一个py文件，去掉注释和每一行右侧的空格，然后在前端显示出来（要保证左侧空格在页面显示)</p></li></ul><p>二轮技术面or三轮技术面：</p><ul><li><p>一个业务场景，每天发贴量比较大，怎么存储在数据库</p></li><li><p>mysql inner join和left join的区别</p></li><li><p>A leftjoin B where B.mark=True与A innerjoin B where B.mark=True的区别</p></li><li><p>同时多个请求来操作数据库，怎么弄？</p></li><li><p>rest怎么做用户认证？</p></li><li><p>MongoDB有索引么？</p></li><li><p>消息队列在你项目的应用场景是啥？</p></li><li><p>SVN用过么，还是只用过Git</p></li><li><p>爬虫搞得怎么样？#简单看过</p></li><li><p>我看你看过flask源码，Django源码看过么？说只看过session相关的源码</p></li><li><p> 网络协议</p></li></ul><p>。TCP三个握手细节1</p><p>。HTTP状态码(200,200.)3</p><p>数据库</p><p>。Redis有那些数据结构？3</p><ul><li>利用Redis实现一个分布式锁？O</li></ul><p>。假如Rdis里面有1亿个key,其中有10w个ky是以某个固定的已知的前缀开头的，如果将它们全部找出来？0</p><ul><li>Redis如何做持久化的？O</li></ul><p>数据结构</p><ul><li><p>hashtable的低层实现？1</p></li><li><p>CSRF的原理？1</p></li><li><p>一个链表的长度为L(L&gt;N&gt;M),反转M和N之间的节点0</p></li></ul><p>。合并两个已排序的数组？1</p><p>其他</p><ul><li><p>是否使用VPN,VPN的底层原理？O</p></li><li><p>RPC的通用缺点是什么？O</p></li></ul><p>Python的深拷贝和浅拷贝的区别？O</p><ul><li> 有一个多层嵌套列表A=[1,2,[3，4，[“434”,[…]]]]请写一段代码遍 历A 中的每一个元素并打印出来。</li></ul><pre class=" language-python"><code class="language-python">A <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">fan</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">for</span> i <span class="token keyword">in</span> c<span class="token punctuation">:</span>    <span class="token keyword">if</span> type<span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> list<span class="token punctuation">:</span>        fan<span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>fan<span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">flat</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>  res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> nums<span class="token punctuation">:</span>        <span class="token keyword">if</span> isinstance<span class="token punctuation">(</span>i<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>flat<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token keyword">return</span> resalist<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">]</span>a<span class="token operator">=</span>flat<span class="token punctuation">(</span>alist<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span></code></pre><blockquote><p>深浅拷贝都是对源对象的复制，占用不同的内存空间。</p><p>不可变类型的对象，对于深浅拷贝室无影响，最终的地址值和值都是相等的。</p><p>可变类型：</p><p>=浅拷贝：值相等，地址相等</p><p>copy浅拷贝：值相等，地址不相等</p><p>deepcopyi深拷贝：值相等，地址不相等</p></blockquote><ul><li><p> 请简单写一个Python的闭包</p></li><li><p> 关于Python字典中键和值的类型</p></li></ul><p>字典，就是一种通过名字引用值的数据结构。这种结构类型是映射类型。它是一种key-value结构的键值对。键可以是数字、字符串、元组。就像英汉词典一样，可以通过查找某个特定的词语（键），从而找到它的定义（值）。</p><p>键必须是唯一的，但值则不必。值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组</p><ul><li> python可hash类型和不可hash类型</li></ul><p><a href="https://blog.csdn.net/weixin_44871977/article/details/106535536">(65条消息) python可hash类型和不可hash类型_Lifelrving的博客-CSDN博客</a></p><ul><li> python序列类型包括哪三种</li></ul><p><a href="https://blog.csdn.net/Python_cresss/article/details/104986839">(65条消息) python序列类型包括哪三种_Python_cresss的博客-CSDN博客</a></p><ul><li> python中地板除是什么意思_解析python 中/ 和 % 和 //（地板除）</li></ul><p><a href="https://blog.csdn.net/weixin_39984963/article/details/110504836">(65条消息) python中地板除是什么意思_解析python 中/ 和 % 和 //（地板除）_weixin_39984963的博客-CSDN博客</a></p><ul><li><p> 解释Python脚本程序的“_name”变量及其作用。</p></li><li><p>简单解释Python的字符串驻留机制。</p></li><li><p>简述什么是浏览器事件流。</p></li><li><p>解释下HTTP常见响应状态码</p></li><li><p>Python是如何进行内存管理的？</p></li></ul><blockquote><ol><li><p>说一下python的GIL锁</p></li><li><p>Linux熟悉吗？</p></li><li><p>Git熟练嘛？<code>git add a.txt</code>的时候，都干了什么？</p></li><li><p>你是怎么使用Docker的？</p></li><li><p>说说我们这个职位对应的业务？docker在里面起到什么作用？</p></li><li><p>MySQL高可用知道吗？</p></li><li><p>XSS攻击说一下</p></li><li><p>Tornado用过没？他与其它Web框架的区别？</p></li><li><p>说一下快排如何实现</p></li><li><p>你在学这些技术的过程中，觉得哪里亮点高？</p></li><li><p>Linux中你开一个进程，在里面打开了一个文件，那么当你创建一个子进程的时候，这个文件状态是什么样子的？</p></li><li><p>后来发现这是个坑，回答完之后，他又问我：“那如果我现在在一个进程中创建一个网络连接，通过这个进程创建一个子进程，子进程中有这个网络连接吗？如果没有，为什么？如果有，如何实现通信的？”</p></li><li><p>有没有看过什么源码？</p></li></ol></blockquote><ul><li></li></ul><blockquote><p>介绍性能分析器</p><p>profiler是一个程序，用来描述运行时的程序性能，并且从不同方面提供统计数据加以表述。Python中含有3个模块提供这样的功能，分别是cProfile,profile和pstats。.这些分析器提供的是对Python程序的确定性分析。同时也提供一系列的报表生成工具，允许用户快速地检查分析结果。</p><p>Python标准库提供了3个不同的性能分析器：</p><ol><li><p>cProfile,推荐给大部分的用户，是C的一个扩展应用，因为其合理的运行开销，所以适合分析运行时间较长的。是基于Isprof</p></li><li><p>profile,一个纯python模块，它的接口和cProfile-一致。在分析程序时，增加了很大的运行开销。如果你想扩展profiler的功能，可以试着继承这个模块</p></li><li><p>hotshot,一个试验性的c模块，关注减少分析时的运行开销，但是是以需要更长的数据后处理的次数为代价。不过这个模块不再被维护，也有可能在新的python版本中被弃用。</p></li></ol></blockquote><ul><li> Python：*args 和 **kargs 的作用、用法和区别</li></ul><p><a href="https://www.jianshu.com/p/2ad2837321ef">Python：*args 和 **kargs 的作用、用法和区别-  简书 (jianshu.com)</a></p><pre class=" language-python"><code class="language-python">h<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>k<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span>d<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'a'</span><span class="token punctuation">:</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token keyword">def</span> <span class="token function">f2</span><span class="token punctuation">(</span>arg1<span class="token punctuation">,</span>arg2<span class="token punctuation">,</span><span class="token operator">*</span>args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>arg1<span class="token punctuation">,</span>arg2<span class="token punctuation">,</span>args<span class="token punctuation">,</span>kwargs<span class="token punctuation">)</span>f2<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>c<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span>f2<span class="token punctuation">(</span><span class="token operator">*</span>h<span class="token punctuation">,</span><span class="token operator">*</span>k<span class="token punctuation">,</span><span class="token operator">*</span>d<span class="token punctuation">)</span>f2<span class="token punctuation">(</span>h<span class="token punctuation">,</span>k<span class="token punctuation">,</span><span class="token operator">*</span>d<span class="token punctuation">)</span>f2<span class="token punctuation">(</span>h<span class="token punctuation">,</span>k<span class="token punctuation">,</span>d<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#运行结果：</span><span class="token comment" spellcheck="true">#1 2 (3,) {'a': 1, 'b': 2, 'c': 3}</span><span class="token comment" spellcheck="true">#1 2 (3, 4, 5, 6, 'a', 'b', 'c') {}</span><span class="token comment" spellcheck="true">#[1, 2, 3] (4, 5, 6) ('a', 'b', 'c') {}</span><span class="token comment" spellcheck="true">#[1, 2, 3] (4, 5, 6) ({'a': 7, 'b': 8, 'c': 9},) {}</span></code></pre><ul><li><pre class=" language-python"><code class="language-python">s<span class="token operator">=</span><span class="token punctuation">(</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>str<span class="token operator">=</span><span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>type<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>type<span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span>运行结果：<span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'generator'</span><span class="token operator">></span> <span class="token operator">&lt;</span>generator object <span class="token operator">&lt;</span>genexpr<span class="token operator">></span> at <span class="token number">0x000001EB1BB953C0</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'list'</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span></code></pre></li><li><p> 将函数f2封装到f2.py文件中，请说明python-m cProfile f2.py执行目的，并列举其输出项和含义.</p></li></ul><p>Python基础(11) 性能测试工具 cProfile</p><p><a href="https://blog.csdn.net/irving512/article/details/109446870">(65条消息) Python基础(11) 性能测试工具 cProfile_清欢守护者的博客-CSDN博客</a></p><ul><li><p> 解释一下Python中的继承</p></li><li><p> 怎样获取字典中所有键的列表</p></li><li><p> 用python统计日志中IP的数量</p></li></ul><p><a href="https://cloud.tencent.com/developer/article/1567140">用python统计日志中IP的数量-  腾讯云开发者社区-腾讯云 (tencent.com)</a></p><ul><li><p>  python基础数据类型</p></li><li><p>lambda表达式</p></li><li><p>map,filter,reduce是什么</p></li><li><p>写一个排序</p></li><li><p>贪婪匹配和非贪婪匹配</p></li><li><p>常用的编辑器以及快捷键</p></li><li><p> 如果让你设计api接口，你怎么设计安全性？</p></li><li><p>  Python高并发解决方案</p></li><li><p>  [python]正则表达式实战，提取txt文档的指定内容</p></li><li><p> 在Python中怎么有效读取一个20GB大小的文件？</p></li></ul><p>使用Python实现一个stack。(可以写试卷背面)</p><ul><li><p>  Pythonic指python代码风格，</p></li><li><p> python——魔术方法</p></li></ul><p><a href="https://blog.csdn.net/qq_53893431/article/details/123979718">(65条消息) python——魔术方法_影中人lx的博客-CSDN博客_python魔术方法</a></p><ul><li> python多进程实现数据共享</li></ul><p><a href="https://blog.csdn.net/qq_38312411/article/details/127279257">(65条消息) python多进程实现数据共享_木瓜星灵的博客-CSDN博客_python进程共享数据</a></p><ul><li><p> 常用的l/O多路复用(l/O multiplexing)技术有哪几种？请阐明它们各自的特点及优点</p></li><li><p> 1.请用python代码实现生产者-消费者模型(Producer-consumer problem)(仅限使用python standard library提供的组件，勿使用第三方库)</p></li><li><p> 2.请编写一个开平方函数，其输入为一个double类型非负值，输出为输入值开方的结果，要求保留小数点后6位</p></li><li><p> 现有不数的面就分的1元5元10元，2动元，50元，100的元货币，如果要用这些货币组合成×元，求一共有多少种组合方式？请说出这类问题在算法中被称为什么问题并用代码实现</p></li><li><p> <a href="https://www.jianshu.com/p/de7f04e65618">Tornado异步原理详析-  简书 (jianshu.com)</a></p></li><li><p> 5.请说一说lambda函数的作用，请用ambda和reduce实现1到100的累加</p></li><li><p> 4,请实现一个装饰器，限制该函数被调用的频率，如10秒一次</p></li><li><p> a=[1,2,3,4]</p></li></ul><p>print(id(a[:]))</p><p>print(id(a))</p><p>答案：</p><p>2731666792704</p><p>2731666783104</p><ul><li> 题目描述  输入：</li></ul><p>wo men 123 shi zu guo de 32144 hua guo,</p><p>wo men 34523 shi zu guo de 3256144 hua guo,</p><p>wo men 4234 shi zu guo de 44345 hua guo,</p><p>wo men 12345433 shi zu guo de 4323125 hua guo,</p><p>输出：</p><p>wo men afanti shi zu guo de afanti hua guo,</p><p>wo men afanti shi zu guo de afanti hua guo,</p><p>wo men afanti shi zu guo de afanti hua guo,</p><p>wo men afanti shi zu guo de afanti hua guo,</p><p>代码：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> res <span class="token operator">=</span> <span class="token triple-quoted-string string">'''wo men 123 shi zu guo de 32144 hua guo,wo men 34523 shi zu guo de 3256144 hua guo,wo men 4234 shi zu guo de 44345 hua guo,wo men 12345433 shi zu guo de 4323125 hua guo,'''</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span><span class="token string">'\d+'</span><span class="token punctuation">,</span> <span class="token string">"afanti"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#结果:</span><span class="token comment" spellcheck="true">#wo men afanti shi zu guo de afanti hua guo,</span><span class="token comment" spellcheck="true">#wo men afanti shi zu guo de afanti hua guo,</span><span class="token comment" spellcheck="true">#wo men afanti shi zu guo de afanti hua guo,</span><span class="token comment" spellcheck="true">#wo men afanti shi zu guo de afanti hua guo,</span></code></pre><ul><li> 深拷贝和浅拷贝</li></ul><p>浅拷贝：语法：copy.copy()，浅拷贝是创建了一个和原对象一样的类型，但是其内容是对原对象元素的引用。</p><p>深拷贝：语法：copy.deepcopy(),在内存中将所有的数据重新建立一份。</p><blockquote><p>不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；</p><p>可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。</p></blockquote><blockquote><p>Python中可迭代对象(Iterable)并不是指某种具体的数据类型，它是指存储了元素的一个容器对象，且容器中的元素可以通过__iter__( )方法或__getitem__( )方法访问。iter__ 方法的作用是让对象可以用for … in循环遍历，getitem( )方法是让对象可以通过“实例名[index]”的方式访问实例中的元素。老猿认为这两个方法的目的是Python实现一个通用的外部可以访问可迭代对象内部数据的接口.一个可迭代对象是不能独立进行迭代的，Python中，迭代是通过for … in来完成的。凡是可迭代对象都可以直接用for… in…循环访问，这个语句其实做了两件事：第一件事是调用iter()获得一个可迭代器，第二件事是循环调用next__()。</p><p>常见的可迭代对象包括：</p><ul><li><p>集合数据类型，如list、tuple、dict、set、str等；</p></li><li><p>生成器(generator)，包括生成器和带yield的生成器函数(generator function) </p></li><li><p>如何判断一个对象是可迭代对象呢？可以通过collections模块的Iterable类型判断，具体判断方法如下：from collections import Iterable #导入Iterable 模块isinstance(变量, Iterable) #判断一个变量是否为可迭代对象返回True表明是可迭代对象</p></li></ul></blockquote><ul><li> 列表推导式：列表(list)推导式字典(dict)推导式集合(set)推导式元组(tuple)推导式</li></ul><pre class=" language-python"><code class="language-python">a <span class="token operator">=</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>i<span class="token punctuation">,</span> i <span class="token operator">*</span> i<span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> a<span class="token punctuation">]</span>c <span class="token operator">=</span> <span class="token punctuation">{</span>i<span class="token punctuation">:</span> i <span class="token operator">*</span> i <span class="token keyword">for</span> i <span class="token keyword">in</span> a<span class="token punctuation">}</span><span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#[[0, 0], [1, 1], [2, 4], [3, 9], [4, 16], [5, 25], [6, 36], [7, 49], [8, 64], [9, 81]]</span><span class="token comment" spellcheck="true">#{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}</span></code></pre><ul><li><p> 现有字典d={‘a‘:26,’g’:20,‘e’:22,’c’:24,‘d’:23,‘f’:21,’b‘:25}请按照字段中的value字段进行排序</p></li><li><p> 用正则表达式实现匹配手机号（包含手机号码前带86或是+86的情况）</p></li></ul><blockquote><ul><li>  项目相关：</li></ul><p>​      rbac是个什么东西</p><p>​      rbac的实现逻辑，怎么做到限制到按钮级别的（忘记了，没回答好）</p><p>​      CMDB是做什么的（我写了这个项目，不过具体实现我并不知道，我回答的时候做了一下作用，具体实现说忘记了）</p><ul><li>python相关：</li></ul><p>​      classmethod和staticmethod的调用方式</p><p>​      djang的请求流程</p></blockquote><blockquote><ul><li>引用计数机制：在Python中，整数和短小的字符，Python都会缓存这些对象，以便重复使用。赋值语句，只是创造了新的引用，而不是对象本身。长的字符串和其它对象可以有多个相同的对象，可以使用赋值语句创建出新的对象。每个对象都有存有指向该对象的引用总数，即引用计数(reference count)。:</li><li>垃圾回收机制：引用计数也是一种垃圾收集机制，而且也是一种最直观，最简单的垃圾收集技术。当Python的某个对象的引用计数降为0时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。</li><li>内存池机制：Python的内存机制呈现金字塔形状，-1，-2层主要有操作系统进行操作；第0层是C中的malloc,free等内存分配和释放函数进行操作；第1层和第2层是内存池，有Python的接口函数PyMem_Malloc函数实现，当对象小于256K时有该层直接分配内存；第3层是最上层，也就是我们对Python对象的直接操作；</li></ul></blockquote><ul><li><p> 描述对super、pass、yield、lambda关键字修饰的理解。</p></li><li><p> 请大致描述一下python的GL机制，以及python中多线程和多进程的区别.。</p></li><li><p> python是如何进行内存管理的，以及大致描述一下python的GC机制，</p></li><li><p> 请分别描述一下类装饰器和函数修饰器的实现过程及应用场景。</p></li><li><p> 请用两个队列来实现一个栈（给出伪代码即可）。</p></li><li><p>实现一个Singleton单例类。要求遵循基本语言编程规范</p></li><li><p>请实现一个简单的socket编程。要求：</p></li></ul><p>实现server端的功能即可</p><p>遵循基本语言编程规范</p><ul><li> 请为掌阅设计一个并发处理KEY-VALUE引擎，要求每条请求的数据小于16k,数据总量为1T,QPS为50要求：</li></ul><p>1),请给出该系统需要配备多少资源，服务器数量，服务器内存大小及硬盘空间等</p><p>2),要求系统平滑可扩展，高可用</p><p>3),尽可能的降低系统复杂度</p><ul><li> Python collections模块之deque()详解</li></ul><p><a href="https://blog.csdn.net/chl183/article/details/106958004">(65条消息) Python collections模块之deque()详解_chl183的博客-CSDN博客_deque()</a></p><ul><li> 下面的写法，哪些会出销，为什么？</li></ul><pre class=" language-python"><code class="language-python">a<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>a<span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">2</span>a<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">3</span>a<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">4</span></code></pre><ul><li><p> 简述多线程同步服务器和单线程异步服务器的区别、以及优缺点</p></li><li><p> 查找当前目录以及子目录下所有的*.pyc文件，并删除。</p></li><li><p> 考察基本数据结构，简述Hash的实现原理，并列举2种解决冲突的方法。</p></li><li><p> 简述python中多线程与多进程之间的区别及各自试用场景</p></li><li><p> 简单描述下快运排序法的原理</p></li><li><p> 如求二进制中1的个数</p></li><li><p> 一个文本文件，大的有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想</p></li><li><p> 12个大小一样的球，其中一个的重量与其他的不一样，如何只称3次我出这只球？</p></li><li><p> 电梯运行算法设计</p></li><li><p> 如何用Python米进行查询和替换一个文本字符串？</p></li><li><p> 10.举例说明异常模块中try except else finally的相关意义</p></li><li><p> 简述python.异步调用的原理或过程，或写出示例代码</p></li></ul><blockquote><p>一.项目问题：</p><p>你写爬虫的时候都遇到过什么反爬虫措施，你是怎样解决的</p><p>用的什么框架。为什么选择这个框架</p><p>二.框架问题：</p><p>scrapy的基本结构（五个部分都是什么，请求发出去的整个流程）</p><p>scrapy的去重原理（指纹去重到底是什么原理）</p><p>scrapy中间件有几种类，你用过哪些中间件</p><p>scrapy中间件在哪里起的作业（面向切片编程）</p><p>三.代理问题：</p><p>为什么会用到代理</p><p>代理怎么使用（具体代码， 请求在什么时候添加的代理）</p><p>代理失效了怎么处理</p><p>四.验证码处理：</p><p>登陆验证码处理</p><p>爬取速度过快出现的验证码处理</p><p>如何用机器识别验证码</p><p>五.模拟登陆问题：</p><p>模拟登陆流程</p><p>cookie如何处理</p><p>如何处理网站传参加密的情况</p><p>六.分布式：</p><p>分布式原理</p><p>分布式如何判断爬虫已经停止了</p><p>分布式的去重原理</p><p>七.数据存储和数据库问题：</p><p>关系型数据库和非关系型数据库的区别</p><p>爬下来数据你会选择什么存储方式，为什么</p><p>各种数据库支持的数据类型，和特点</p><p>是否支持事务…</p><p>八.Python基础问题：</p><p>基础问题非常多，但是因为爬虫性质，还是有些问的比较多的，下面总结：</p><p>Python2和Python3的区别，如何实现python2代码迁移到Python3环境</p><p>Python2和Python3的编码方式有什么差别</p><p>迭代器，生成器，装饰器</p><p>Python的数据类型</p><p>九.协议问题：</p><p>http协议，请求由什么组成，每个字段分别有什么用，https和http有什么差距</p><p>证书问题</p><p>TCP，UDP各种相关问题</p><p>十.数据提取问题：</p><p>主要使用什么样的结构化数据提取方式，可能会写一两个例子</p><p>正则的使用</p><p>动态加载的数据如何提取</p><p>json数据如何提取</p><p>十一.算法问题：</p><p>算法：你们要善用Python的数据类型，对Python的数据结构深入了解</p><p>Python WEB面试常见问题</p><p>一. python语法以及其他基础部分：</p><p>可变与不可变类型</p><p>浅拷贝与深拷贝的实现方式、区别；deepcopy如果你来设计，如何实现</p><p>new() 与 init()的区别</p><p>你知道几种设计模式</p><p>编码和解码你了解过么</p><p>列表推导list comprehension和生成器的优劣</p><p>什么是装饰器；如果想在函数之后进行装饰，应该怎么做</p><p>手写个使用装饰器实现的单例模式</p><p>使用装饰器的单例和使用其他方法的单例，在后续使用中，有何区别</p><p>手写：正则邮箱地址</p><p>介绍下垃圾回收：引用计数/分代回收/孤立引用环</p><p>多进程与多线程的区别,CPU密集型适合用什么</p><p>进程通信的方式有几种</p><p>介绍下协程，为何比线程还快</p><p>range和xrange的区别</p><p>二. 算法排序部分：</p><p>手写快排；堆排；几种常用排序的算法复杂度是多少；快排平均复杂度多少，最坏情况如何优化</p><p>手写：已知一个长度n的无序列表，元素均是数字，要求把所有间隔为d的组合找出来，你写的解法算法复杂度多少</p><p>手写：一个列表A=[A1，A2，…,An]，要求把列表中所有的组合情况打印出来；</p><p>手写：用一行python写出1+2+3+…+10**8</p><p>手写python：用递归的方式判断字符串是否为回文</p><p>单向链表长度未知，如何判断其中是否有环</p><p>单向链表如何使用快速排序算法进行排序</p><p>手写：一个长度n的无序数字元素列表，如何求中位数，如何尽快的估算中位数，9).你的算法复杂度是多少；</p><p>如何遍历一个内部未知的文件夹（两种树的优先遍历方式）</p><p>三. 网络基础部分：</p><p>TCP/IP分别在模型的哪一层</p><p>socket长连接是什么意思</p><p>select和epoll你了解么，区别在哪</p><p>TCP UDP区别；三次握手四次挥手讲一下</p><p>TIME_WAIT过多是因为什么</p><p>http一次连接的全过程：你来说下从用户发起request——到用户接收到 response</p><p>http连接方式。get和post的区别，你还了解其他的方式么</p><p>restful你知道么</p><p>状态码你知道多少，比如200/403/404/504等等</p><p>四. 数据库部分：</p><p>MySQL锁有几种；死锁是怎么产生的； 为何，以及如何分区、分表；</p><p>MySQL的char varchar text的区别:</p><p>了解join么,有几种有何区别，A LEFT JOIN B，查询的结果中，B没有的那部分是如何显示的(NULL)</p><p>索引类型有几种，BTree索引和hash索引的区别</p><p>手写：如何对查询命令进行优化</p><p>NoSQL了解么，和关系数据库的区别,redis有几种常用存储类型</p><p>五. Linux部分：</p><p>讲一下你常用的Linux/git命令和作用；</p><p>查看当前进程是用什么命令，除了文件相关的操作外，你平时还有什么操作命令；</p><p>六. Django项目部分:</p><p>都是让简单的介绍下你在公司的项目，不管是不是后端相关的，主要是要体现出你干了什么</p><p>你在项目中遇到最难的部分是什么，你是怎么解决的； 你看过django的admin源码么</p><p>看过flask的源码么,你如何理解开源</p><p>MVC / MTV, 缓存怎么用, 中间件是干嘛的</p><p>CSRF是什么，django是如何避免的,XSS</p><p>如果你来设计login，简单的说一下思路</p><p>session和cookie的联系与区别,session为什么说是安全的</p><p>uWSGI和Nginx的作用；</p></blockquote><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul><li><p>在GNU Linux操作系统中，如何查找文件名为newton.py的文件。</p></li><li><p>请简述GNU Linux环境变量的用途</p></li><li><p>在GNU Linux中如何查询当前主机的内存使用情况。</p></li><li><p>在GNU Linux中如何查询当前主机的防火墙设置。</p></li><li><p>在Git中如何使用master、.branch、TAG?</p></li><li><p>编写一个脚本，5分钟检查一次日志，发现有暴力SS破解现象的，提取此类P地址，并去重，并技降序排序，要求：同一个P暴力破解超过10次，自动屏蔽1P地址，指定办公室P地址(192.168.100.100)为可信任P地址，不受屏蔽规则限制，以下为日志格日志样板如下：</p></li></ul><p>May 4 03:43:07 tz-monitor sshd[14003]:Failed password for root from 124.232.135.84 port 25251ssh2</p><p>May 4 03:43:07 tz-monitor sshd[14082]:Invalid user postgres from 124.232.135.84</p><ul><li><p>画出TCP三次握手，四次握手断开示意图</p></li><li><p>业务服务器192.168.1.2访问192.168.1.3数据接口，无法正常返回数据，请根据以上给出信息写出排查思路</p></li><li><p>python中如下一个字典，请按照key进行排序</p></li></ul><p>ct_tmp =[‘carry’:’17,’bob’:’21,’matty’:23jack’:’33’,’tom’:’16’,’alex’:’23’</p><ul><li>tables识考察，根据要求写出防火墙规则？<ul><li>屏蔽192.168.1.5访问本机dns服务端口：</li><li>允许10.1.1.0/24访问本机的udp 8888 9999端口</li></ul></li></ul><p><a href="https://blog.csdn.net/daocaokafei/article/details/115091313">(65条消息) Linux iptables命令详解_一口Linux的博客-CSDN博客_iptable命令</a></p><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><ul><li><p>叙述MySQL半同步复制原理</p></li><li><p>存储引擎、索引原理、事务原理、锁机制等和优化能力</p></li><li><p>请列举常见的MySQL存储引擎</p></li><li><p>InnoDB有哪些特性</p></li><li><p>请列出一些MySQL数据库查询优化的技巧</p></li><li><p>请简述SQL注入的攻击原理及如何在代码层面防止SOL注入</p></li><li><p>请简述MySQL查询时如何关联多张表</p></li><li><p>假设mysql中表A存储着某次考试中每个学生每道题的得分，含有三列：student id(学生)、question_id(题目)、score(得分)，请用sql查询出每个学生的总分。</p></li><li><p>关系型数据库中，表与表之间有左连接、内连接、外连接。分别解释下他们的含义及区别？</p></li><li><p>mysql中表A有三列a,b,c。索引为a,ab,unique a_b._c。sql语句：select*from table1 where a=10;,会命中哪个索引？</p></li><li><p>给定的有序整数列表L,使用二分法查找整数在L中的位置，如果未找到返回None。(本页写不完可以写在背面)</p></li><li><p>存储引擎哪几种/有什么区别</p></li><li><p>索引(有哪几种索引，索引之间的区别，索引的作用，什么情况下不适合建索引，组合索引的命中规则</p></li><li><p>inner join/left join/right jion的区别</p></li></ul><h3 id="Data-structure"><a href="#Data-structure" class="headerlink" title="Data structure"></a>Data structure</h3><ul><li>队列与栈的定义：<ul><li>队列（Queue）：是限定只能在表的一端进行插入和在另一端进行删除操作的线性表；</li><li>栈（Stack）：是限定只能在表的一端进行插入和删除操作的线性表。</li></ul></li><li>队列与栈的区</li></ul><p>队列和栈是两种不同的数据结构。它们有以下区别：</p><p>（1）操作的名称不同。</p><p>队列的插入称为入队，队列的删除称为出队。栈的插入称为进栈，栈的删除称为出栈。</p><p>（2）操作的限定不同。</p><p>队列是在队尾入队，队头出队，即两边都可操作。而栈的进栈和出栈都是在栈顶进行的，无法对栈底直接进行操作。</p><p>（3）操作的规则不同。</p><p>队列是先进先出（FIFO），即队列的修改是依先进先出的原则进行的。新来的成员总是加入队尾（不能从中间插入），每次离开的成员总是队列头上（不允许中途离队）。而栈为后进先出（LIFO）,即每次删除（出栈）的总是当前栈中最新的元素，即最后插入（进栈）的元素，而最先插入的被放在栈的底部，要到最后才能删除。</p><p>（4）遍历数据速度不同。</p><p>队列是基于地址指针进行遍历，而且可以从头部或者尾部进行遍历，但不能同时遍历，无需开辟空间，因为在遍历的过程中不影响数据结构，所以遍历速度要快。栈是只能从顶部取数据，也就是说最先进入栈底的，需要遍历整个栈才能取出来，而且在遍历数据的同时需要为数据开辟临时空间，保持数据在遍历前的一致性。</p><ul><li><p>编写快速排序或者冒泡排序</p></li><li><p> 连表的冒泡排序</p></li><li><p>树的顺序遍历</p></li><li><p>顺序表的快速排序</p></li></ul><h3 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h3><ul><li><p>请列举经常访问的技术网站或博客</p></li><li><p>请列举最近关注的一些技术</p></li><li><p>请列举你认为不错的一些技术书籍和你最近在看的书籍（不限于技术）</p></li><li><p>请列举你阅读过源码的一些项目</p></li><li><p>请给出你对这份笔试题的看法 </p></li><li><p>简述Django对HTTP请求的执行流程</p></li><li><p>简述Django下的（内建的）缓存机制</p></li><li><p>Django里queryset的get和fliter方法的区别</p></li><li><p>Django中Model的slugfield类型的字段的用途是什么</p></li><li><p>Django中如何加载初始化数据 </p></li><li><p>MYSQL有哪些存储引擎，优化MYSQL数据库的方法有哪些？</p></li><li><p>WEB开发中session与cookie的作用与区别？</p></li><li><p>WEB开发中有哪些技术手段防止SQL注入？</p></li><li><p>请列举常见的HTTP头及其作用</p></li><li><p>请列举常见的HTTP状态响应码及其意义</p></li><li><p>请简述对RESTful API设计规范的理解</p></li><li><p>请简述HTTP缓存机制</p></li><li><p>请简述Cookie和Session之间的关系</p></li><li><p>OSI七层参考模型详解</p></li></ul><p><a href="https://blog.csdn.net/Ggggggggggu/article/details/124158378">(65条消息) OSI七层参考模型详解（简单通俗易懂）_Ggggggggggu的博客-CSDN博客_osi参考模型</a></p><ul><li><p>如何查看http的并发请求数与其TCP连接状态</p></li><li><p>写出抓包查看到192.168.5.100服务器的8080端口的命令</p></li><li><p>ps aux中的VSZ代表什么意思，RSS代表什么意思？</p></li></ul><table><thead><tr><th><strong>函数</strong></th><th><strong>返回值</strong> <strong>(</strong> <strong>描述</strong> <strong>)</strong></th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/python3/python3-func-number-abs.html">abs(x)</a></td><td>返回数字的绝对值，如abs(-10) 返回 10</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-ceil.html">ceil(x)</a></td><td>返回数字的上入整数，如math.ceil(4.1) 返回 5</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-exp.html">exp(x)</a></td><td>返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-fabs.html">fabs(x)</a></td><td>返回数字的绝对值，如math.fabs(-10) 返回10.0</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-floor.html">floor(x)</a></td><td>返回数字的下舍整数，如math.floor(4.9)返回 4</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-log.html">log(x)</a></td><td>如math.log(math.e)返回1.0,math.log(100,10)返回2.0</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-log10.html">log10(x)</a></td><td>返回以10为基数的x的对数，如math.log10(100)返回 2.0</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-max.html">max(x1, x2,…)</a></td><td>返回给定参数的最大值，参数可以为序列。</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-min.html">min(x1, x2,…)</a></td><td>返回给定参数的最小值，参数可以为序列。</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-modf.html">modf(x)</a></td><td>返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-pow.html">pow(x, y)</a></td><td>x**y 运算后的值。</td></tr><tr><td>[round(x <a href="https://www.runoob.com/python3/python3-func-number-round.html">,n])</a></td><td>返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。  <strong>其实准确的说是保留值将保留到离上一位更近的一端。</strong></td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-sqrt.html">sqrt(x)</a></td><td>返回数字x的平方根。</td></tr></tbody></table><p>列表的成员方法</p><table><thead><tr><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>list.append(x)</td><td>把一个元素添加到列表的结尾，相当于 a[len(a):] =  [x]。</td></tr><tr><td>list.extend(L)</td><td>通过添加指定列表的所有元素来扩充列表，相当于 a[len(a):] =  L。</td></tr><tr><td>list.insert(i, x)</td><td>在指定位置插入一个元素。第一个参数是准备插入到其前面的那个元素的索引，例如 a.insert(0,  x) 会插入到整个列表之前，而 a.insert(len(a), x) 相当于 a.append(x) 。</td></tr><tr><td>list.remove(x)</td><td>删除列表中值为 x 的第一个元素。如果没有这样的元素，就会返回一个错误。</td></tr><tr><td>list.pop([i])</td><td>从列表的指定位置移除元素，并将其返回。如果没有指定索引，a.pop()返回最后一个元素。元素随即从列表中被移除。（方法中 i 两边的方括号表示这个参数是可选的，而不是要求你输入一对方括号，你会经常在 Python 库参考手册中遇到这样的标记。）</td></tr><tr><td>list.clear()</td><td>移除列表中的所有项，等于del a[:]。</td></tr><tr><td>list.index(x)</td><td>返回列表中第一个值为 x 的元素的索引。如果没有匹配的元素就会返回一个错误。</td></tr><tr><td>list.count(x)</td><td>返回 x 在列表中出现的次数。</td></tr><tr><td>list.sort()</td><td>对列表中的元素进行排序。</td></tr><tr><td>list.reverse()</td><td>倒排列表中的元素。</td></tr><tr><td>list.copy()</td><td>返回列表的浅复制，等于a[:]。</td></tr></tbody></table><h3 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a>持续更新…</h3>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Linxu </tag>
            
            <tag> SQL </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 网络 </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Datta Able Django学习</title>
      <link href="/2022/11/20/datta-able-django-xue-xi/"/>
      <url>/2022/11/20/datta-able-django-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="Datta-Able-Django"><a href="#Datta-Able-Django" class="headerlink" title="Datta Able Django"></a><a href="https://appseed.us/product/datta-able/django/">Datta Able Django</a></h1><p>Open-source <strong>Django Dashboard</strong> generated by <code>AppSeed</code> op top of a modern design. <strong><a href="https://appseed.us/product/datta-able/django/">Datta Able</a></strong> Bootstrap Lite is the most stylised Bootstrap 4 Lite Admin Template, around all other Lite/Free admin templates in the market. It comes with high feature-rich pages and components with fully developer-centric code.</p><h2 id="How-to-use-it"><a href="#How-to-use-it" class="headerlink" title="How to use it"></a>How to use it</h2><h3 id="Set-Up-for-Windows"><a href="#Set-Up-for-Windows" class="headerlink" title="Set Up for Windows"></a>Set Up for <code>Windows</code></h3><blockquote><p>Install modules via <code>VENV</code> (windows)</p></blockquote><pre><code>$ virtualenv env$ .\env\Scripts\activate$ pip3 install -r requirements.txt</code></pre><blockquote><p>Set Up Database</p></blockquote><pre class=" language-bash"><code class="language-bash">$ python manage.py makemigrations$ python manage.py migrate</code></pre><blockquote><p>Start the app</p></blockquote><pre class=" language-bash"><code class="language-bash">$ python manage.py runserver</code></pre><p>At this point, the app runs at <code>http://127.0.0.1:8000/</code>.</p><h2 id="Code-base-structure"><a href="#Code-base-structure" class="headerlink" title="Code-base structure"></a>Code-base structure</h2><p>The project is coded using a simple and intuitive structure presented below:</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span> PROJECT ROOT <span class="token operator">></span>   <span class="token operator">|</span>   <span class="token operator">|</span>-- core/                               <span class="token comment" spellcheck="true"># Implements app configuration</span>   <span class="token operator">|</span>    <span class="token operator">|</span>-- settings.py                    <span class="token comment" spellcheck="true"># Defines Global Settings</span>   <span class="token operator">|</span>    <span class="token operator">|</span>-- wsgi.py                        <span class="token comment" spellcheck="true"># Start the app in production</span>   <span class="token operator">|</span>    <span class="token operator">|</span>-- urls.py                        <span class="token comment" spellcheck="true"># Define URLs served by all apps/nodes</span>   <span class="token operator">|</span>   <span class="token operator">|</span>-- apps/   <span class="token operator">|</span>    <span class="token operator">|</span>   <span class="token operator">|</span>    <span class="token operator">|</span>-- home/                          <span class="token comment" spellcheck="true"># A simple app that serve HTML files</span>   <span class="token operator">|</span>    <span class="token operator">|</span>    <span class="token operator">|</span>-- views.py                  <span class="token comment" spellcheck="true"># Serve HTML pages for authenticated users</span>   <span class="token operator">|</span>    <span class="token operator">|</span>    <span class="token operator">|</span>-- urls.py                   <span class="token comment" spellcheck="true"># Define some super simple routes  </span>   <span class="token operator">|</span>    <span class="token operator">|</span>   <span class="token operator">|</span>    <span class="token operator">|</span>-- authentication/                <span class="token comment" spellcheck="true"># Handles auth routes (login and register)</span>   <span class="token operator">|</span>    <span class="token operator">|</span>    <span class="token operator">|</span>-- urls.py                   <span class="token comment" spellcheck="true"># Define authentication routes  </span>   <span class="token operator">|</span>    <span class="token operator">|</span>    <span class="token operator">|</span>-- views.py                  <span class="token comment" spellcheck="true"># Handles login and registration  </span>   <span class="token operator">|</span>    <span class="token operator">|</span>    <span class="token operator">|</span>-- forms.py                  <span class="token comment" spellcheck="true"># Define auth forms (login and register) </span>   <span class="token operator">|</span>    <span class="token operator">|</span>   <span class="token operator">|</span>    <span class="token operator">|</span>-- static/   <span class="token operator">|</span>    <span class="token operator">|</span>    <span class="token operator">|</span>-- <span class="token operator">&lt;</span>css, JS, images<span class="token operator">></span>         <span class="token comment" spellcheck="true"># CSS files, Javascripts files</span>   <span class="token operator">|</span>    <span class="token operator">|</span>   <span class="token operator">|</span>    <span class="token operator">|</span>-- templates/                     <span class="token comment" spellcheck="true"># Templates used to render pages</span>   <span class="token operator">|</span>         <span class="token operator">|</span>-- includes/                 <span class="token comment" spellcheck="true"># HTML chunks and components</span>   <span class="token operator">|</span>         <span class="token operator">|</span>    <span class="token operator">|</span>-- navigation.html      <span class="token comment" spellcheck="true"># Top menu component</span>   <span class="token operator">|</span>         <span class="token operator">|</span>    <span class="token operator">|</span>-- sidebar.html         <span class="token comment" spellcheck="true"># Sidebar component</span>   <span class="token operator">|</span>         <span class="token operator">|</span>    <span class="token operator">|</span>-- footer.html          <span class="token comment" spellcheck="true"># App Footer</span>   <span class="token operator">|</span>         <span class="token operator">|</span>    <span class="token operator">|</span>-- scripts.html         <span class="token comment" spellcheck="true"># Scripts common to all pages</span>   <span class="token operator">|</span>         <span class="token operator">|</span>   <span class="token operator">|</span>         <span class="token operator">|</span>-- layouts/                   <span class="token comment" spellcheck="true"># Master pages</span>   <span class="token operator">|</span>         <span class="token operator">|</span>    <span class="token operator">|</span>-- base-fullscreen.html  <span class="token comment" spellcheck="true"># Used by Authentication pages</span>   <span class="token operator">|</span>         <span class="token operator">|</span>    <span class="token operator">|</span>-- base.html             <span class="token comment" spellcheck="true"># Used by common pages</span>   <span class="token operator">|</span>         <span class="token operator">|</span>   <span class="token operator">|</span>         <span class="token operator">|</span>-- accounts/                  <span class="token comment" spellcheck="true"># Authentication pages</span>   <span class="token operator">|</span>         <span class="token operator">|</span>    <span class="token operator">|</span>-- login.html            <span class="token comment" spellcheck="true"># Login page</span>   <span class="token operator">|</span>         <span class="token operator">|</span>    <span class="token operator">|</span>-- register.html         <span class="token comment" spellcheck="true"># Register page</span>   <span class="token operator">|</span>         <span class="token operator">|</span>   <span class="token operator">|</span>         <span class="token operator">|</span>-- home/                      <span class="token comment" spellcheck="true"># UI Kit Pages</span>   <span class="token operator">|</span>              <span class="token operator">|</span>-- index.html            <span class="token comment" spellcheck="true"># Index page</span>   <span class="token operator">|</span>              <span class="token operator">|</span>-- 404-page.html         <span class="token comment" spellcheck="true"># 404 page</span>   <span class="token operator">|</span>              <span class="token operator">|</span>-- *.html                <span class="token comment" spellcheck="true"># All other pages</span>   <span class="token operator">|</span>   <span class="token operator">|</span>-- requirements.txt                     <span class="token comment" spellcheck="true"># Development modules - SQLite storage</span>   <span class="token operator">|</span>   <span class="token operator">|</span>-- .env                                 <span class="token comment" spellcheck="true"># Inject Configuration via Environment</span>   <span class="token operator">|</span>-- manage.py                            <span class="token comment" spellcheck="true"># Start the app - Django default start script</span>   <span class="token operator">|</span>   <span class="token operator">|</span>-- ************************************************************************</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态Title</title>
      <link href="/2022/10/21/dong-tai-title/"/>
      <url>/2022/10/21/dong-tai-title/</url>
      
        <content type="html"><![CDATA[<h3 id="方法1：document-title方式"><a href="#方法1：document-title方式" class="headerlink" title="方法1：document.title方式"></a>方法1：document.title方式</h3><p>经过测试，还可通过document.title 设置title的值。</p><pre><code>document.title = '需要设置的值';</code></pre><p>例子</p><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>hello<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript">            document<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string">'php中文网'</span><span class="token punctuation">;</span>        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><h3 id="方法2：利用jQuery的html-或text-方法"><a href="#方法2：利用jQuery的html-或text-方法" class="headerlink" title="方法2：利用jQuery的html()或text()方法"></a>方法2：利用jQuery的html()或text()方法</h3><p>当然如果你的项目里面依赖jQuery，可以使用jq的方法设置。</p><p>jq中两种方式都可以实现</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'title'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">html</span><span class="token punctuation">(</span><span class="token string">'需要设置的值'</span><span class="token punctuation">)</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'title'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token string">'需要设置的值'</span><span class="token punctuation">)</span></code></pre><p>例子</p><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>hello<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>js/jquery-1.7.2.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript">        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript">             <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'title'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">html</span><span class="token punctuation">(</span><span class="token string">'php中文网'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'title'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token string">'php中文网'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MVT和MVC的区别</title>
      <link href="/2022/10/06/mvt-he-mvc-de-qu-bie/"/>
      <url>/2022/10/06/mvt-he-mvc-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<h2 id="1-理解MVT和MVC"><a href="#1-理解MVT和MVC" class="headerlink" title="1.理解MVT和MVC"></a>1.理解MVT和MVC</h2><h3 id="MVC（Model-View-Controller-模型-视图-控制器）"><a href="#MVC（Model-View-Controller-模型-视图-控制器）" class="headerlink" title="MVC（Model View Controller 模型-视图-控制器）"></a>MVC（Model View Controller 模型-视图-控制器）</h3><p>特点：把业务逻辑、模型数据、用户界面分离开来，让开发者将数据与表现**<u>解耦</u>**。</p><p>解耦：降低各功能模块之间的耦合性，方便变更，更容易重构代码，最大程度上实现代码的重用</p><p>Model： 代表数据存取层，</p><p>View 代表的是系统中选择显示什么和怎么显示的部分，</p><p>Controller 指的是系统中根据用户输入并视需要访问模型，以决定使用哪个视图的那部分。</p><p><img src="https://gitee.com/sainthood2077/cloudimg/raw/main/images/image-20221006112114601.png" alt="image-20221006112114601"></p><p>客户端发送请求，通过控制台分发请求，将请求发到数据库中，通过实体类，它与数据库具有一一对应的关系<br>然后数据库返回数据，将数据封装成对象，返回到控制器，控制器将其渲染到页面上，返回给客户。</p><h3 id="MVT（Model-View-Templates-模型-视图-模板）"><a href="#MVT（Model-View-Templates-模型-视图-模板）" class="headerlink" title="MVT（Model View Templates 模型-视图-模板）"></a>MVT（Model View Templates 模型-视图-模板）</h3><p>Models：数据存取层。 该层处理与数据相关的所有事务： 如何存取、如何验证有效，是一个抽象层，用来构建和操作你的web应用中的数据，模型是你的数据的唯一的、权威的信息源。它包含你所储存数据的必要字段和行为。通常，每个模型对应数据库中唯一的一张表。</p><p>视图（views）：业务逻辑层，该层包含存取模型及调取恰当模板的相关逻辑。用于封装负责处理用户请求及返回响应的逻辑。视图可以看作是前端与数据库的中间人，他会将前端想要的数据从数据库中读出来给前端。他也会将用户要想保存的数据写到数据库。</p><p>模板(templates)：即表现层。 该层处理与表现相关的决定： 如何在页面或其他类型文档中进行显示。模板层提供了设计友好的语法来展示信息给用户。使用模板方法可以动态地生成HTML。模板包含所需HTML 输出的静态部分，以及一些特殊的语法，描述如何将动态内容插入。</p><p><img src="https://gitee.com/sainthood2077/cloudimg/raw/main/images/image-20221006112038348.png" alt="image-20221006112038348"></p><p>客户端发送请求，django路由分发请求，视图函数接收参数，控制流程，通过实体类（与数据库有映射关系）将请求发送到<br>数据库中，数据库返回数据，将数据在MODL层封装成对象，返回到视图函数，视图函数将其渲染到模板层（页面），返回<br>给客户端。</p><h2 id="2-区别："><a href="#2-区别：" class="headerlink" title="2.区别："></a>2.区别：</h2><p>​        MVC中的View的目的是「呈现哪一个数据」，而MTV的View的目的是「数据如何呈现」。也就是把MVT中的View分成了视图（展现哪些数据）和模板（如何展现）2个部分，而Contorller这个要素由框架自己来实现了，我们需要做的就是把（带正则表达式的）URL对应到视图就可以了，通过这样的URL配置，系统将一个请求发送到一个合适的视图。</p><p>MVC（控制层用来接收参数，控制流程，分发请求），MVT（模板层用来展示页面，省去了分发请求的步骤，将其交给了django路由）</p>]]></content>
      
      
      
        <tags>
            
            <tag> Django模型 </tag>
            
            <tag> MVT </tag>
            
            <tag> MVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django项目学习</title>
      <link href="/2022/10/04/django-xiang-mu-xue-xi/"/>
      <url>/2022/10/04/django-xiang-mu-xue-xi/</url>
      
        <content type="html"><![CDATA[<p>今天开始学习Django，再此记录一下学习过程以便过后复习查看</p><h2 id="一、部署Django"><a href="#一、部署Django" class="headerlink" title="一、部署Django"></a>一、部署Django</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h3><pre class=" language-python"><code class="language-python">pip install django</code></pre><h3 id="2-生成Django"><a href="#2-生成Django" class="headerlink" title="2.生成Django"></a>2.生成Django</h3><p>首先尽量没有中文路径的Django</p><pre class=" language-python"><code class="language-python"><span class="token string">"D:\Ananconda3\Anaconda\Scripts\django-admin.exe"</span> startproject 项目名称<span class="token comment" spellcheck="true"># 如果"D:\Ananconda3\Anaconda\Scripts\"已经加入环境变量</span>django<span class="token operator">-</span>admin<span class="token punctuation">.</span>exe startporject 项目名称</code></pre><p>创建成功截图：</p><p><img src="https://gitee.com/sainthood2077/cloudimg/raw/main/images/image-20221005000620128.png" alt="文件目录"></p><h3 id="3-文件说明"><a href="#3-文件说明" class="headerlink" title="3.文件说明"></a>3.文件说明</h3><pre class=" language-python"><code class="language-python">WMS │─manage<span class="token punctuation">.</span>py           <span class="token punctuation">[</span>项目的管理、启动、创建APP<span class="token punctuation">]</span><span class="token punctuation">[</span>无需修改，经常使用<span class="token punctuation">]</span> │ └─WMS                 <span class="token punctuation">[</span>项目名同名文件夹<span class="token punctuation">]</span>      │─asgi<span class="token punctuation">.</span>py        <span class="token punctuation">[</span>接受网络请求<span class="token punctuation">]</span><span class="token punctuation">[</span>无需修改<span class="token punctuation">]</span>      │─settings<span class="token punctuation">.</span>py    <span class="token punctuation">[</span>配置文件<span class="token punctuation">]</span><span class="token punctuation">[</span>数据库配置，时区，安装的APP，中间件，日志配置，以及一些基本的目录配置<span class="token punctuation">]</span>      │─urls<span class="token punctuation">.</span>py           <span class="token punctuation">[</span>包含一个urlpatterns变量，其实它就是一个URLDispacher（URL分派器）<span class="token punctuation">,</span>用于在URL和实际的view之间建立一个映射<span class="token punctuation">]</span>      │─wsgi<span class="token punctuation">.</span>py           <span class="token punctuation">[</span>接受网络请求<span class="token punctuation">]</span><span class="token punctuation">[</span>无需修改<span class="token punctuation">]</span>      └─__init__<span class="token punctuation">.</span>py    <span class="token punctuation">[</span>说明内部的WMS目录是一个python模块<span class="token punctuation">]</span></code></pre><h2 id="二、APP概念"><a href="#二、APP概念" class="headerlink" title="二、APP概念"></a>二、APP概念</h2><h3 id="1、作用"><a href="#1、作用" class="headerlink" title="1、作用"></a>1、作用</h3><p>APP相当于一个相对独立的功能模块，其遵循的设计理念是MVT（类似MVC）；在一个大型的Project中，可以包含很多APP，而且每个APP可以在不同的Project中复用，这也符合Django的编程理念，即：不要做重复的事情。</p><p>并且每个APP都有独立的表结构、函数、HTML模板、CSS</p><h3 id="2、创建"><a href="#2、创建" class="headerlink" title="2、创建"></a>2、创建</h3><pre class=" language-python"><code class="language-python">python manage<span class="token punctuation">.</span>py startapp app名称</code></pre><h3 id="3、APP目录结构"><a href="#3、APP目录结构" class="headerlink" title="3、APP目录结构"></a>3、APP目录结构</h3><pre class=" language-python"><code class="language-python">wmsapp    │  admin<span class="token punctuation">.</span>py          <span class="token punctuation">[</span>无需修改<span class="token punctuation">]</span><span class="token punctuation">[</span>默认提供的admin后台<span class="token punctuation">]</span>    │  apps<span class="token punctuation">.</span>py           <span class="token punctuation">[</span>无需修改<span class="token punctuation">]</span>    │  models<span class="token punctuation">.</span>py         <span class="token punctuation">[</span>操作数据库，ORM<span class="token punctuation">]</span>    │  tests<span class="token punctuation">.</span>py          <span class="token punctuation">[</span>无需修改<span class="token punctuation">]</span><span class="token punctuation">[</span>单元测试<span class="token punctuation">]</span>    │  views<span class="token punctuation">.</span>py          <span class="token punctuation">[</span>URL Dispacher即将URL请求映射到这个文件中的函数或类方法上<span class="token punctuation">]</span>    │  __init__<span class="token punctuation">.</span>py       <span class="token punctuation">[</span>说明polls目录是一个python模块<span class="token punctuation">]</span>    │    └─migrations        <span class="token punctuation">[</span>记录数据库变更<span class="token punctuation">]</span>            __init__<span class="token punctuation">.</span>py</code></pre><h2 id="三、项目部署"><a href="#三、项目部署" class="headerlink" title="三、项目部署"></a>三、项目部署</h2><h3 id="1-注册APP"><a href="#1-注册APP" class="headerlink" title="1.注册APP"></a>1.注册APP</h3><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># /WMS/settings.py</span>INSTALLED_APPS <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token string">"django.contrib.admin"</span><span class="token punctuation">,</span>    <span class="token string">"django.contrib.auth"</span><span class="token punctuation">,</span>    <span class="token string">"django.contrib.contenttypes"</span><span class="token punctuation">,</span>    <span class="token string">"django.contrib.sessions"</span><span class="token punctuation">,</span>    <span class="token string">"django.contrib.messages"</span><span class="token punctuation">,</span>    <span class="token string">"django.contrib.staticfiles"</span><span class="token punctuation">,</span>    <span class="token string">"wmsapp.apps.appconfig"</span><span class="token punctuation">,</span>           <span class="token operator">&lt;</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>插入，即注册成功<span class="token punctuation">]</span></code></pre><h3 id="2-编写url与视图函数的关系"><a href="#2-编写url与视图函数的关系" class="headerlink" title="2.编写url与视图函数的关系"></a>2.编写url与视图函数的关系</h3><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># /WMS/urls.py</span><span class="token keyword">from</span> wmsapp <span class="token keyword">import</span> viewsurlpatterns <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token comment" spellcheck="true"># path("admin/", admin.site.urls),</span>    <span class="token comment" spellcheck="true"># www.xxx.com/index/</span>    path<span class="token punctuation">(</span><span class="token string">"index/"</span><span class="token punctuation">,</span> views<span class="token punctuation">.</span>index<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">]</span></code></pre><h3 id="3-编写视图函数"><a href="#3-编写视图函数" class="headerlink" title="3.编写视图函数"></a>3.编写视图函数</h3><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># wmsapp/views.py</span><span class="token keyword">from</span> django<span class="token punctuation">.</span>shortcuts <span class="token keyword">import</span> render<span class="token punctuation">,</span>HttpResponse<span class="token keyword">def</span> <span class="token function">index</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> HttpResponse<span class="token punctuation">(</span><span class="token string">"欢迎使用Django！"</span><span class="token punctuation">)</span></code></pre><h3 id="4-启动Django"><a href="#4-启动Django" class="headerlink" title="4.启动Django"></a>4.启动Django</h3><h4 id="1、代码启动"><a href="#1、代码启动" class="headerlink" title="1、代码启动"></a>1、代码启动</h4><pre class=" language-python"><code class="language-python">python manage<span class="token punctuation">.</span>py runserver</code></pre><h4 id="2、项目启动"><a href="#2、项目启动" class="headerlink" title="2、项目启动"></a>2、项目启动</h4><p><img src="https://gitee.com/sainthood2077/cloudimg/raw/main/images/image-20221007100945752.png" alt="启动位置"></p><p>运行成功</p><p><img src="https://gitee.com/sainthood2077/cloudimg/raw/main/images/image-20221007100900404.png" alt="成功界面"></p><h3 id="5、创建页面"><a href="#5、创建页面" class="headerlink" title="5、创建页面"></a>5、创建页面</h3><p>wmsapp/  新建templates文件夹</p><p><img src="https://gitee.com/sainthood2077/cloudimg/raw/main/images/image-20221007102243886.png" alt="urls.py和views.py对应关系"></p><p>根据app的注册顺序，注意搜索他们templates下的文件</p><h3 id="6、静态文件"><a href="#6、静态文件" class="headerlink" title="6、静态文件"></a>6、静态文件</h3><p>wasapp/ 新建static文件夹，下存放CSS、js、图片</p><p>引入：</p><p><img src="https://gitee.com/sainthood2077/cloudimg/raw/main/images/image-20221007104813123.png" alt="Django的特殊引入方式"></p><h3 id="7-模板语法"><a href="#7-模板语法" class="headerlink" title="7.模板语法"></a>7.模板语法</h3><p>基本模板语法</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># wmsapp/views.py</span><span class="token keyword">def</span> <span class="token function">user_list</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>    n1 <span class="token operator">=</span> <span class="token string">"lisi"</span>    n2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span><span class="token string">"wangwu"</span><span class="token punctuation">,</span><span class="token string">"xiaoming"</span><span class="token punctuation">]</span>    n3 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"mingzi"</span><span class="token punctuation">:</span><span class="token string">"lizhi"</span><span class="token punctuation">,</span><span class="token string">"nianling"</span><span class="token punctuation">:</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token string">"zhiwei"</span><span class="token punctuation">:</span><span class="token string">"laoban"</span><span class="token punctuation">}</span>    <span class="token keyword">return</span> render<span class="token punctuation">(</span>request<span class="token punctuation">,</span><span class="token string">"user_list.html"</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"n1"</span><span class="token punctuation">:</span>n1<span class="token punctuation">,</span><span class="token string">"n2"</span><span class="token punctuation">:</span>n2<span class="token punctuation">,</span><span class="token string">"n3"</span><span class="token punctuation">:</span>n3<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>user_list.html</p><pre class=" language-python"><code class="language-python"><span class="token operator">&lt;</span>span<span class="token operator">></span><span class="token punctuation">{</span> <span class="token punctuation">{</span> n3 <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span><span class="token operator">&lt;</span>span<span class="token operator">></span><span class="token punctuation">{</span> <span class="token punctuation">{</span> n3<span class="token punctuation">.</span>mingzi <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span><span class="token operator">&lt;</span>span<span class="token operator">></span><span class="token punctuation">{</span> <span class="token punctuation">{</span> n3<span class="token punctuation">.</span>nianling <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span><span class="token operator">&lt;</span>span<span class="token operator">></span><span class="token punctuation">{</span> <span class="token punctuation">{</span> n3<span class="token punctuation">.</span>zhiwei <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span><span class="token operator">&lt;</span>div<span class="token operator">></span>    <span class="token punctuation">{</span> <span class="token operator">%</span> <span class="token keyword">for</span> item <span class="token keyword">in</span> n3<span class="token punctuation">.</span>keys <span class="token operator">%</span> <span class="token punctuation">}</span>        <span class="token operator">&lt;</span>span<span class="token operator">></span><span class="token punctuation">{</span> <span class="token punctuation">{</span> item <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span>    <span class="token punctuation">{</span> <span class="token operator">%</span> endfor <span class="token operator">%</span> <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span>div<span class="token operator">></span>    <span class="token punctuation">{</span> <span class="token operator">%</span> <span class="token keyword">for</span> item <span class="token keyword">in</span> n3<span class="token punctuation">.</span>values <span class="token operator">%</span> <span class="token punctuation">}</span>        <span class="token operator">&lt;</span>span<span class="token operator">></span><span class="token punctuation">{</span> <span class="token punctuation">{</span> item <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span>    <span class="token punctuation">{</span> <span class="token operator">%</span> endfor <span class="token operator">%</span> <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span>div<span class="token operator">></span>    <span class="token punctuation">{</span> <span class="token operator">%</span> <span class="token keyword">for</span> k<span class="token punctuation">,</span>v <span class="token keyword">in</span> n3<span class="token punctuation">.</span>items <span class="token operator">%</span> <span class="token punctuation">}</span>    <span class="token operator">&lt;</span>span<span class="token operator">></span><span class="token punctuation">{</span> <span class="token punctuation">{</span> k <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">{</span> v <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span>    <span class="token punctuation">{</span> <span class="token operator">%</span> endfor <span class="token operator">%</span> <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span>hr<span class="token operator">></span><span class="token operator">&lt;</span>div<span class="token operator">></span>    <span class="token punctuation">{</span> <span class="token operator">%</span> <span class="token keyword">if</span> n1 <span class="token operator">==</span> <span class="token string">"lisi"</span> <span class="token operator">%</span> <span class="token punctuation">}</span>        <span class="token operator">&lt;</span>span<span class="token operator">></span>n1是lisi<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span>    <span class="token punctuation">{</span> <span class="token operator">%</span> <span class="token keyword">else</span> <span class="token operator">%</span> <span class="token punctuation">}</span>        <span class="token operator">&lt;</span>span<span class="token operator">></span>n1不是lisi<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span>    <span class="token punctuation">{</span> <span class="token operator">%</span> endif <span class="token operator">%</span> <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span></code></pre><h2 id="四、ORM数据库操作"><a href="#四、ORM数据库操作" class="headerlink" title="四、ORM数据库操作"></a>四、ORM数据库操作</h2><p><img src="https://gitee.com/sainthood2077/cloudimg/raw/main/images/image-20221007154916296.png" alt="ORM运行机制解释"></p><h3 id="1-安装mysqlclient"><a href="#1-安装mysqlclient" class="headerlink" title="1.安装mysqlclient"></a>1.安装mysqlclient</h3><pre class=" language-python"><code class="language-python">pip install mysqlclient</code></pre><p>windows系统安装错误的可以进入mysqlclient下载安装包安装</p><h3 id="2-ORM"><a href="#2-ORM" class="headerlink" title="2.ORM"></a>2.ORM</h3><ul><li>无需写sql语句</li><li>可以增删改查数据表</li><li><strong>无法创建数据库（需要手动创建）</strong></li></ul><h3 id="3-连接数据库"><a href="#3-连接数据库" class="headerlink" title="3.连接数据库"></a>3.连接数据库</h3><p>WMS/settings.py  将databases修改为下面的代码</p><pre class=" language-python"><code class="language-python">DATABASES <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token string">"default"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token string">"ENGINE"</span><span class="token punctuation">:</span> <span class="token string">"django.db.backends.mysql"</span><span class="token punctuation">,</span>        <span class="token string">"NAME"</span><span class="token punctuation">:</span> <span class="token string">"wmsdb"</span><span class="token punctuation">,</span>        <span class="token string">"USER"</span><span class="token punctuation">:</span> <span class="token string">"root"</span><span class="token punctuation">,</span>        <span class="token string">"PASSWORD"</span><span class="token punctuation">:</span> <span class="token string">"root"</span><span class="token punctuation">,</span>        <span class="token string">"HOST"</span><span class="token punctuation">:</span> <span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span>        <span class="token string">"POST"</span><span class="token punctuation">:</span> <span class="token number">3306</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="4-ORM编辑表"><a href="#4-ORM编辑表" class="headerlink" title="4.ORM编辑表"></a>4.ORM编辑表</h3><h4 id="1-创建表"><a href="#1-创建表" class="headerlink" title="1.创建表"></a>1.创建表</h4><p>wmsapp/Models.py</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">UserInfo</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>    name <span class="token operator">=</span> models<span class="token punctuation">.</span>CharField<span class="token punctuation">(</span>max_length<span class="token operator">=</span><span class="token number">32</span><span class="token punctuation">)</span>    password<span class="token operator">=</span>models<span class="token punctuation">.</span>CharField<span class="token punctuation">(</span>max_length<span class="token operator">=</span><span class="token number">64</span><span class="token punctuation">)</span>    age<span class="token operator">=</span>models<span class="token punctuation">.</span>IntegerField<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>如上代码等同于在数据库里执行：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> app01 userinfo<span class="token punctuation">(</span>    id <span class="token keyword">bigint</span> <span class="token keyword">auto_increment</span> <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">,</span>    name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    password <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    age <span class="token keyword">int</span><span class="token punctuation">,</span><span class="token punctuation">)</span></code></pre><pre class=" language-python"><code class="language-python">python manage<span class="token punctuation">.</span>py makemigrationspython manage<span class="token punctuation">.</span>py migrate</code></pre><h4 id="2-删除表"><a href="#2-删除表" class="headerlink" title="2.删除表"></a>2.删除表</h4><p>注释不需要的字段或表，并执行&gt; python manage.py makemigrations &gt; python manage.py migrate 命令，即删除表</p><h4 id="3-修改表"><a href="#3-修改表" class="headerlink" title="3.修改表"></a>3.修改表</h4><p>在&lt;现有的&gt;表中添加新的字段，执行命令会提示：</p><p><img src="https://gitee.com/sainthood2077/cloudimg/raw/main/images/image-20221019195444497.png" alt="提示截图"></p><blockquote><p>在没有指定默认值的情况下，不可能向goodsinfo添加不可为空的字段“size”。这是因为数据库需要一些东西来填充现有的行。 请选择一个修复: </p><p>1)现在提供一次性默认值（将在所有现有行上设置，并且此列为空值）</p><p>2)退出并在models.py中手动定义一个默认值。 </p><p>选择一个选项:</p></blockquote><ul><li>选择1：</li></ul><p><img src="https://gitee.com/sainthood2077/cloudimg/raw/main/images/image-20221019200032147.png" alt="（1）"></p><p>会有求&gt;&gt;&gt;输入一个值，作为默认值（这里我输入的是0）</p><ul><li>选择2：</li></ul><p>会直接退出，可以手动为其添加一个默认值</p><pre class=" language-python"><code class="language-python">size <span class="token operator">=</span> models<span class="token punctuation">.</span>IntegerField<span class="token punctuation">(</span>default<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>log <span class="token operator">=</span> models<span class="token punctuation">.</span>IntegerField<span class="token punctuation">(</span>null<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>blank<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 默认为空</span></code></pre><h3 id="5-ORM字段介绍"><a href="#5-ORM字段介绍" class="headerlink" title="5.ORM字段介绍"></a>5.ORM字段介绍</h3><p>Djan提供了很多字段类型，比如URL/Email/IP/ 但是mysql数据没有这些类型，这类型存储到数据库上本质是字符串数据类型,其主要目的是为了封装底层SQL语句；</p><ul><li><p>字符串类（以下都是在数据库中本质都是字符串数据类型，此类字段只是在Django自带的admin中生效）</p><pre class=" language-python"><code class="language-python">EmailField<span class="token punctuation">(</span>CharField<span class="token punctuation">)</span>：IPAddressField<span class="token punctuation">(</span>Field<span class="token punctuation">)</span>URLField<span class="token punctuation">(</span>CharField<span class="token punctuation">)</span>SlugField<span class="token punctuation">(</span>CharField<span class="token punctuation">)</span>UUIDField<span class="token punctuation">(</span>Field<span class="token punctuation">)</span>FilePathField<span class="token punctuation">(</span>Field<span class="token punctuation">)</span>FileField<span class="token punctuation">(</span>Field<span class="token punctuation">)</span>ImageField<span class="token punctuation">(</span>FileField<span class="token punctuation">)</span>CommaSeparatedIntegerField<span class="token punctuation">(</span>CharField<span class="token punctuation">)</span></code></pre></li></ul><blockquote><p>提示：models.CharField  对应的是MySQL的varchar数据类型</p><p><strong>char 和 varchar的区别</strong> :</p><p>char和varchar的共同点是存储数据的长度，不能 超过max_length限制，</p><p>不同点是varchar根据数据实际长度存储，char按指定max_length（）存储数据；所有前者更节省硬盘空间；</p></blockquote><ul><li><p>时间字段</p><pre class=" language-py"><code class="language-py">models.DateTimeField(null=True)date=models.DateField()</code></pre></li><li><p>数字字段</p><pre class=" language-python"><code class="language-python"><span class="token punctuation">(</span>max_digits<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">,</span>decimal_places<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span>总长度<span class="token number">30</span>小数位 <span class="token number">10</span>位）num <span class="token operator">=</span> models<span class="token punctuation">.</span>IntegerField<span class="token punctuation">(</span><span class="token punctuation">)</span>num <span class="token operator">=</span> models<span class="token punctuation">.</span>FloatField<span class="token punctuation">(</span><span class="token punctuation">)</span> 浮点price<span class="token operator">=</span>models<span class="token punctuation">.</span>DecimalField<span class="token punctuation">(</span>max_digits<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">,</span>decimal_places<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span> 精确浮点</code></pre></li><li><p>枚举字段</p><pre class=" language-python"><code class="language-python"> choice<span class="token operator">=</span><span class="token punctuation">(</span>        <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'男人'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'女人'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'其他'</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span>lover<span class="token operator">=</span>models<span class="token punctuation">.</span>IntegerField<span class="token punctuation">(</span>choices<span class="token operator">=</span>choice<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#枚举类型</span></code></pre><p><strong>扩展</strong></p><p>在数据库存储枚举类型，比外键有什么优势？</p><p>1、无需连表查询性能低，省硬盘空间(选项不固定时用外键)<br>2、在modle文件里不能动态增加（选项一成不变用Django的choice）</p></li><li><p>其他字段</p><pre class=" language-python"><code class="language-python">db_index <span class="token operator">=</span> <span class="token boolean">True</span> 表示设置索引unique<span class="token punctuation">(</span>唯一的意思<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">True</span> 设置唯一索引</code></pre></li></ul><h3 id="6-ORM编辑字段"><a href="#6-ORM编辑字段" class="headerlink" title="6.ORM编辑字段"></a>6.ORM编辑字段</h3><p>首先导入类</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># wmsapp/views.py</span><span class="token keyword">from</span> wmsapp <span class="token keyword">import</span> models</code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">index</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 添加字段</span>    models<span class="token punctuation">.</span>UserInfo<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>create<span class="token punctuation">(</span>        name<span class="token operator">=</span><span class="token string">'wangwu'</span><span class="token punctuation">,</span>        mobile<span class="token operator">=</span><span class="token string">'19927343821'</span><span class="token punctuation">,</span>        password<span class="token operator">=</span><span class="token string">'82737373'</span><span class="token punctuation">,</span>        authority<span class="token operator">=</span><span class="token string">'manager'</span>    <span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 删除字段</span>    models<span class="token punctuation">.</span>UserInfo<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>filter<span class="token punctuation">(</span>id<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>delete<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#  筛选指定行数据删除</span>    models<span class="token punctuation">.</span>UserInfo<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>all<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>delete<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#  删除表内全部数据</span>        <span class="token comment" spellcheck="true"># 获取字段信息</span>    db_list <span class="token operator">=</span> models<span class="token punctuation">.</span>UserInfo<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>all<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 无论筛选一行还是获取全部，得到的都是queryset类型</span>    <span class="token keyword">for</span> obj <span class="token keyword">in</span> db_list<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>name<span class="token punctuation">,</span>obj<span class="token punctuation">.</span>mobile<span class="token punctuation">,</span>obj<span class="token punctuation">.</span>password<span class="token punctuation">,</span>obj<span class="token punctuation">.</span>authority<span class="token punctuation">,</span>obj<span class="token punctuation">.</span>sign_time<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 必须要通过循环的形式输出字段信息</span>    row_obj <span class="token operator">=</span> models<span class="token punctuation">.</span>UserInfo<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>all<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>name<span class="token punctuation">,</span>obj<span class="token punctuation">.</span>mobile<span class="token punctuation">,</span>obj<span class="token punctuation">.</span>password<span class="token punctuation">,</span>obj<span class="token punctuation">.</span>authority<span class="token punctuation">,</span>obj<span class="token punctuation">.</span>sign_time<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 因为只有第一行，可以直接打印第一行的字段信息</span>        <span class="token comment" spellcheck="true">#更新字段</span>    models<span class="token punctuation">.</span>UserInfo<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>all<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>update<span class="token punctuation">(</span>password<span class="token operator">=</span><span class="token string">'123012398'</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 添加外键约束</span>    manager <span class="token operator">=</span> models<span class="token punctuation">.</span>ForeignKey<span class="token punctuation">(</span>to<span class="token operator">=</span><span class="token string">"UserInfo"</span><span class="token punctuation">,</span> to_field<span class="token operator">=</span><span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 将货物和管理员绑定，其列名会生成manager_id，字段只能填写绑定的表UserInfo里的ID值</span>        <span class="token comment" spellcheck="true"># 级联删除</span>    manager <span class="token operator">=</span> models<span class="token punctuation">.</span>ForeignKey<span class="token punctuation">(</span>to<span class="token operator">=</span><span class="token string">"UserInfo"</span><span class="token punctuation">,</span> to_field<span class="token operator">=</span><span class="token string">"id"</span><span class="token punctuation">,</span> on_delete<span class="token operator">=</span>models<span class="token punctuation">.</span>CASCADE<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 如果管理员被删除，其所在表GoodsInfo里绑定的货物一并被删除</span>        <span class="token comment" spellcheck="true"># 置空</span>    manager <span class="token operator">=</span> models<span class="token punctuation">.</span>ForeignKey<span class="token punctuation">(</span>to<span class="token operator">=</span><span class="token string">"UserInfo"</span><span class="token punctuation">,</span> to_field<span class="token operator">=</span><span class="token string">"id"</span><span class="token punctuation">,</span> null<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> blank<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> on_delete<span class="token operator">=</span>models<span class="token punctuation">.</span>SET_NULL<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 如果管理员被删除，其所在表GoodsInfo里绑定的货物会被为空，前提要设置可为空</span>        <span class="token keyword">return</span> HttpResponse<span class="token punctuation">(</span><span class="token string">"欢迎使用Django！"</span><span class="token punctuation">)</span></code></pre><h2 id="ModelForm组件"><a href="#ModelForm组件" class="headerlink" title="ModelForm组件"></a>ModelForm组件</h2><h2 id="admin后台"><a href="#admin后台" class="headerlink" title="admin后台"></a>admin后台</h2><h3 id="1-在admin中注册模型"><a href="#1-在admin中注册模型" class="headerlink" title="1.在admin中注册模型"></a>1.在admin中注册模型</h3><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># wms/admin.py</span> <span class="token keyword">from</span> django<span class="token punctuation">.</span>contrib <span class="token keyword">import</span> admin<span class="token keyword">from</span> <span class="token punctuation">.</span> <span class="token keyword">import</span> models admin<span class="token punctuation">.</span>site<span class="token punctuation">.</span>register<span class="token punctuation">(</span>models<span class="token punctuation">.</span>User<span class="token punctuation">)</span></code></pre><h3 id="2-创建超级管理员"><a href="#2-创建超级管理员" class="headerlink" title="2.创建超级管理员"></a>2.创建超级管理员</h3><pre class=" language-python"><code class="language-python">python manage<span class="token punctuation">.</span>py createsuperuser</code></pre><p>顺序填写用户名、邮箱、密码</p><h2 id="图形验证码"><a href="#图形验证码" class="headerlink" title="图形验证码"></a>图形验证码</h2><p>验证码（CAPTCHA）是“Completely Automated Public Turing test to tell Computers and Humans Apart”（全自动区分计算机和人类的图灵测试）的缩写，是一种区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水，有效防止某个黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。</p><p>图形验证码的历史比较悠久，到现在已经有点英雄末路的味道了。因为机器学习、图像识别的存在，机器人已经可以比较正确的识别图像内的字符了。但不管怎么说，作为一种防御手段，至少还是可以抵挡一些低级入门的攻击手段，抬高了攻击者的门槛。</p><p>采用python的第三方库，pip install django-simple-captcha，Django自动帮我们安装了相关的依赖库<code>six</code>、<code>olefile</code>和<code>Pillow</code>，其中的Pillow是大名鼎鼎的绘图模块</p><h3 id="1-注册captcha"><a href="#1-注册captcha" class="headerlink" title="1.注册captcha"></a>1.注册captcha</h3><pre class=" language-python"><code class="language-python">INSTALLED_APPS <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token string">'django.contrib.admin'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.auth'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.contenttypes'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.sessions'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.messages'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.staticfiles'</span><span class="token punctuation">,</span>    <span class="token string">'captcha'</span><span class="token punctuation">,</span><span class="token punctuation">]</span></code></pre><h3 id="2-设置图形验证码的样式"><a href="#2-设置图形验证码的样式" class="headerlink" title="2.设置图形验证码的样式"></a>2.设置图形验证码的样式</h3><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># wms/settings.py</span><span class="token comment" spellcheck="true">#字母验证码</span>CAPTCHA_IMAGE_SIZE <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">80</span><span class="token punctuation">,</span> <span class="token number">45</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 设置 captcha 图片大小</span>CAPTCHA_LENGTH <span class="token operator">=</span> <span class="token number">4</span>   <span class="token comment" spellcheck="true"># 字符个数</span>CAPTCHA_TIMEOUT <span class="token operator">=</span> <span class="token number">1</span>   <span class="token comment" spellcheck="true"># 超时(minutes)</span>  <span class="token comment" spellcheck="true">#加减乘除验证码</span>CAPTCHA_OUTPUT_FORMAT <span class="token operator">=</span> <span class="token string">'%(image)s %(text_field)s %(hidden_field)s '</span>CAPTCHA_NOISE_FUNCTIONS <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'captcha.helpers.noise_null'</span><span class="token punctuation">,</span>      <span class="token string">'captcha.helpers.noise_arcs'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true"># 线</span>     <span class="token string">'captcha.helpers.noise_dots'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true"># 点</span><span class="token punctuation">)</span>CAPTCHA_CHALLENGE_FUNCT <span class="token operator">=</span> <span class="token string">'captcha.helpers.random_char_challenge'</span>CAPTCHA_CHALLENGE_FUNCT <span class="token operator">=</span> <span class="token string">'captcha.helpers.math_challenge'</span>CAPTCHA_TIMEOUT <span class="token operator">=</span> <span class="token number">1</span></code></pre><p>captcha需要在数据库中建立自己的数据表，所以需要执行migrate命令生成数据表：</p><pre class=" language-python"><code class="language-python">python manage<span class="token punctuation">.</span>py migrate</code></pre><h3 id="2-添加url路由"><a href="#2-添加url路由" class="headerlink" title="2.添加url路由"></a>2.添加url路由</h3><pre class=" language-python"><code class="language-python">url<span class="token punctuation">(</span>r<span class="token string">'^captcha'</span><span class="token punctuation">,</span> include<span class="token punctuation">(</span><span class="token string">'captcha.urls'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 增加这一行</span></code></pre><p>在前端添加captcha内容</p><pre class=" language-python"><code class="language-python"><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"form-group"</span><span class="token operator">></span>    <span class="token punctuation">{</span> <span class="token punctuation">{</span> login_form<span class="token punctuation">.</span>captcha<span class="token punctuation">.</span>errors <span class="token punctuation">}</span> <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true"># 用于提示验证码错误</span>    <span class="token punctuation">{</span> <span class="token punctuation">{</span> login_form<span class="token punctuation">.</span>captcha<span class="token punctuation">.</span>label_tag <span class="token punctuation">}</span> <span class="token punctuation">}</span>    <span class="token punctuation">{</span> <span class="token punctuation">{</span> login_form<span class="token punctuation">.</span>captcha <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span></code></pre><p>其中验证图形码是否正确的工作都是在后台自动完成的，只需要使用<code>is_valid()</code>这个forms内置的验证方法就一起进行了，完全不需要在视图函数中添加任何的验证代码，非常方便快捷！</p><h2 id="Session会话"><a href="#Session会话" class="headerlink" title="Session会话"></a>Session会话</h2><p>因为因特网HTTP协议的特性，每一次来自于用户浏览器的请求（request）都是无状态的、独立的。通俗地说，就是无法保存用户状态，后台服务器根本就不知道当前请求和以前及以后请求是否来自同一用户。对于静态网站，这可能不是个问题，而对于动态网站，尤其是京东、天猫、银行等购物或金融网站，无法识别用户并保持用户状态是致命的，根本就无法提供服务。你可以尝试将浏览器的cookie功能关闭，你会发现将无法在京东登录和购物。</p><p>为了实现连接状态的保持功能，网站会通过用户的浏览器在用户机器内被限定的硬盘位置中写入一些数据，也就是所谓的Cookie。通过Cookie可以保存一些诸如用户名、浏览记录、表单记录、登录和注销等各种数据。但是这种方式非常不安全，因为Cookie保存在用户的机器上，如果Cookie被伪造、篡改或删除，就会造成极大的安全威胁，因此，现代网站设计通常将Cookie用来保存一些不重要的内容，实际的用户数据和状态还是以Session会话的方式保存在服务器端。</p><p>Session依赖Cookie！但与Cookie不同的地方在于Session将所有的数据都放在服务器端，用户浏览器的Cookie中只会保存一个非明文的识别信息，比如哈希值。</p><p>Django提供了一个通用的Session框架，并且可以使用多种session数据的保存方式：</p><ul><li>保存在数据库内</li><li>保存到缓存</li><li>保存到文件内</li><li>保存到cookie内</li></ul><p>通常情况，没有特别需求的话，请使用保存在数据库内的方式，尽量不要保存到Cookie内。</p><p>Django的session框架默认启用，并已经注册在app设置内，如果真的没有启用，那么参考下面的内容添加有说明的那两行，再执行migrate命令创建数据表，就可以使用session了。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Application definition</span> INSTALLED_APPS <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token string">'django.contrib.admin'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.auth'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.contenttypes'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.sessions'</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true"># 这一行</span>    <span class="token string">'django.contrib.messages'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.staticfiles'</span><span class="token punctuation">,</span><span class="token punctuation">]</span> MIDDLEWARE <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token string">'django.middleware.security.SecurityMiddleware'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.sessions.middleware.SessionMiddleware'</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># 这一行</span>    <span class="token string">'django.middleware.common.CommonMiddleware'</span><span class="token punctuation">,</span>    <span class="token string">'django.middleware.csrf.CsrfViewMiddleware'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.auth.middleware.AuthenticationMiddleware'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.messages.middleware.MessageMiddleware'</span><span class="token punctuation">,</span>    <span class="token string">'django.middleware.clickjacking.XFrameOptionsMiddleware'</span><span class="token punctuation">,</span><span class="token punctuation">]</span></code></pre><p>当session启用后，传递给视图request参数的HttpRequest对象将包含一个session属性，就像一个字典对象一样。你可以在Django的任何地方读写<code>request.session</code>属性，或者多次编辑使用它。</p><p>下面是session使用参考：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">backends</span><span class="token punctuation">.</span>base<span class="token punctuation">.</span>SessionBase        <span class="token comment" spellcheck="true"># 这是所有会话对象的基类，包含标准的字典方法:</span>        __getitem__<span class="token punctuation">(</span>key<span class="token punctuation">)</span>            Example<span class="token punctuation">:</span> fav_color <span class="token operator">=</span> request<span class="token punctuation">.</span>session<span class="token punctuation">[</span><span class="token string">'fav_color'</span><span class="token punctuation">]</span>        __setitem__<span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>            Example<span class="token punctuation">:</span> request<span class="token punctuation">.</span>session<span class="token punctuation">[</span><span class="token string">'fav_color'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'blue'</span>        __delitem__<span class="token punctuation">(</span>key<span class="token punctuation">)</span>            Example<span class="token punctuation">:</span> <span class="token keyword">del</span> request<span class="token punctuation">.</span>session<span class="token punctuation">[</span><span class="token string">'fav_color'</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 如果不存在会抛出异常</span>        __contains__<span class="token punctuation">(</span>key<span class="token punctuation">)</span>            Example<span class="token punctuation">:</span> <span class="token string">'fav_color'</span> <span class="token keyword">in</span> request<span class="token punctuation">.</span>session        get<span class="token punctuation">(</span>key<span class="token punctuation">,</span> default<span class="token operator">=</span>None<span class="token punctuation">)</span>            Example<span class="token punctuation">:</span> fav_color <span class="token operator">=</span> request<span class="token punctuation">.</span>session<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'fav_color'</span><span class="token punctuation">,</span> <span class="token string">'red'</span><span class="token punctuation">)</span>        pop<span class="token punctuation">(</span>key<span class="token punctuation">,</span> default<span class="token operator">=</span>__not_given<span class="token punctuation">)</span>            Example<span class="token punctuation">:</span> fav_color <span class="token operator">=</span> request<span class="token punctuation">.</span>session<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token string">'fav_color'</span><span class="token punctuation">,</span> <span class="token string">'blue'</span><span class="token punctuation">)</span></code></pre><pre class=" language-python"><code class="language-python"> <span class="token comment" spellcheck="true"># 类似字典数据类型的内置方法</span>        keys<span class="token punctuation">(</span><span class="token punctuation">)</span>        items<span class="token punctuation">(</span><span class="token punctuation">)</span>        setdefault<span class="token punctuation">(</span><span class="token punctuation">)</span>        clear<span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true"># 它还有下面的方法：</span>        flush<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 删除当前的会话数据和会话cookie。经常用在用户退出后，删除会话。</span>         set_test_cookie<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 设置一个测试cookie，用于探测用户浏览器是否支持cookies。由于cookie的工作机制，你只有在下次用户请求的时候才可以测试。</span>        test_cookie_worked<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 返回True或者False，取决于用户的浏览器是否接受测试cookie。你必须在之前先调用set_test_cookie()方法。</span>        delete_test_cookie<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 删除测试cookie。</span>        set_expiry<span class="token punctuation">(</span>value<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 设置cookie的有效期。可以传递不同类型的参数值：</span>        • 如果值是一个整数，session将在对应的秒数后失效。例如request<span class="token punctuation">.</span>session<span class="token punctuation">.</span>set_expiry<span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span> 将在<span class="token number">300</span>秒后失效<span class="token punctuation">.</span>        • 如果值是一个datetime或者timedelta对象<span class="token punctuation">,</span> 会话将在指定的日期失效        • 如果为<span class="token number">0</span>，在用户关闭浏览器后失效        • 如果为None，则将使用全局会话失效策略        失效时间从上一次会话被修改的时刻开始计时。         get_expiry_age<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 返回多少秒后失效的秒数。对于没有自定义失效时间的会话，这等同于SESSION_COOKIE_AGE.</span>            <span class="token comment" spellcheck="true"># 这个方法接受2个可选的关键字参数</span>        • modification<span class="token punctuation">:</span>会话的最后修改时间（datetime对象）。默认是当前时间。        •expiry<span class="token punctuation">:</span> 会话失效信息，可以是datetime对象，也可以是int或None         get_expiry_date<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 和上面的方法类似，只是返回的是日期</span>         get_expire_at_browser_close<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 返回True或False，根据用户会话是否是浏览器关闭后就结束。</span>         clear_expired<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 删除已经失效的会话数据。</span>        cycle_key<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 创建一个新的会话秘钥用于保持当前的会话数据。django.contrib.auth.login() 会调用这个方法。</span></code></pre><h3 id="使用session"><a href="#使用session" class="headerlink" title="使用session"></a>使用session</h3><p>首先，修改<code>login/views.py</code>中的login()视图函数：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">login</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> request<span class="token punctuation">.</span>session<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'is_login'</span><span class="token punctuation">,</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> redirect<span class="token punctuation">(</span><span class="token string">'/index'</span><span class="token punctuation">)</span>     <span class="token keyword">if</span> request<span class="token punctuation">.</span>method <span class="token operator">==</span> <span class="token string">"POST"</span><span class="token punctuation">:</span>        login_form <span class="token operator">=</span> UserForm<span class="token punctuation">(</span>request<span class="token punctuation">.</span>POST<span class="token punctuation">)</span>        message <span class="token operator">=</span> <span class="token string">"请检查填写的内容！"</span>        <span class="token keyword">if</span> login_form<span class="token punctuation">.</span>is_valid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            username <span class="token operator">=</span> login_form<span class="token punctuation">.</span>cleaned_data<span class="token punctuation">[</span><span class="token string">'username'</span><span class="token punctuation">]</span>            password <span class="token operator">=</span> login_form<span class="token punctuation">.</span>cleaned_data<span class="token punctuation">[</span><span class="token string">'password'</span><span class="token punctuation">]</span>            <span class="token keyword">try</span><span class="token punctuation">:</span>                user <span class="token operator">=</span> models<span class="token punctuation">.</span>User<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>get<span class="token punctuation">(</span>name<span class="token operator">=</span>username<span class="token punctuation">)</span>                <span class="token keyword">if</span> user<span class="token punctuation">.</span>password <span class="token operator">==</span> password<span class="token punctuation">:</span>                    request<span class="token punctuation">.</span>session<span class="token punctuation">[</span><span class="token string">'is_login'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>                    request<span class="token punctuation">.</span>session<span class="token punctuation">[</span><span class="token string">'user_id'</span><span class="token punctuation">]</span> <span class="token operator">=</span> user<span class="token punctuation">.</span>id                    request<span class="token punctuation">.</span>session<span class="token punctuation">[</span><span class="token string">'user_name'</span><span class="token punctuation">]</span> <span class="token operator">=</span> user<span class="token punctuation">.</span>name                    <span class="token keyword">return</span> redirect<span class="token punctuation">(</span><span class="token string">'/index/'</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    message <span class="token operator">=</span> <span class="token string">"密码不正确！"</span>            <span class="token keyword">except</span><span class="token punctuation">:</span>                message <span class="token operator">=</span> <span class="token string">"用户不存在！"</span>        <span class="token keyword">return</span> render<span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token string">'login/login.html'</span><span class="token punctuation">,</span> locals<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     login_form <span class="token operator">=</span> UserForm<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> render<span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token string">'login/login.html'</span><span class="token punctuation">,</span> locals<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>通过下面的if语句，我们不允许重复登录：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">if</span> request<span class="token punctuation">.</span>session<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'is_login'</span><span class="token punctuation">,</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> redirect<span class="token punctuation">(</span><span class="token string">"/index/"</span><span class="token punctuation">)</span></code></pre><p>通过下面的语句，我们往session字典内写入用户状态和数据：</p><pre class=" language-python"><code class="language-python">request<span class="token punctuation">.</span>session<span class="token punctuation">[</span><span class="token string">'is_login'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>request<span class="token punctuation">.</span>session<span class="token punctuation">[</span><span class="token string">'user_id'</span><span class="token punctuation">]</span> <span class="token operator">=</span> user<span class="token punctuation">.</span>idrequest<span class="token punctuation">.</span>session<span class="token punctuation">[</span><span class="token string">'user_name'</span><span class="token punctuation">]</span> <span class="token operator">=</span> user<span class="token punctuation">.</span>name</code></pre><p>你完全可以往里面写任何数据，不仅仅限于用户相关！</p><p>既然有了session记录用户登录状态，那么就可以完善我们的登出视图函数了：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">logout</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token operator">not</span> request<span class="token punctuation">.</span>session<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'is_login'</span><span class="token punctuation">,</span> None<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 如果本来就未登录，也就没有登出一说</span>        <span class="token keyword">return</span> redirect<span class="token punctuation">(</span><span class="token string">"/index/"</span><span class="token punctuation">)</span>    request<span class="token punctuation">.</span>session<span class="token punctuation">.</span>flush<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 或者使用下面的方法</span>    <span class="token comment" spellcheck="true"># del request.session['is_login']</span>    <span class="token comment" spellcheck="true"># del request.session['user_id']</span>    <span class="token comment" spellcheck="true"># del request.session['user_name']</span>    <span class="token keyword">return</span> redirect<span class="token punctuation">(</span><span class="token string">"/index/"</span><span class="token punctuation">)</span></code></pre><p>flush()方法是比较安全的一种做法，而且一次性将session中的所有内容全部清空，确保不留后患。但也有不好的地方，那就是如果你在session中夹带了一点‘私货’，会被一并删除，这一点一定要注意。</p><h3 id="完善页面"><a href="#完善页面" class="headerlink" title="完善页面"></a>完善页面</h3><p>有了用户状态，就可以根据用户登录与否，展示不同的页面，比如导航条内容：</p><p>首先，修改<code>base.html</code>文件：</p><pre class=" language-python"><code class="language-python"> <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"collapse navbar-collapse"</span> id<span class="token operator">=</span><span class="token string">"my-nav"</span><span class="token operator">></span>          <span class="token operator">&lt;</span>ul <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"nav navbar-nav"</span><span class="token operator">></span>            <span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"active"</span><span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"/index/"</span><span class="token operator">></span>主页<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>          <span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">></span>          <span class="token operator">&lt;</span>ul <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"nav navbar-nav navbar-right"</span><span class="token operator">></span>              <span class="token punctuation">{</span> <span class="token operator">%</span> <span class="token keyword">if</span> request<span class="token punctuation">.</span>session<span class="token punctuation">.</span>is_login <span class="token operator">%</span> <span class="token punctuation">}</span>                  <span class="token operator">&lt;</span>li<span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"#"</span><span class="token operator">></span>当前在线：<span class="token punctuation">{</span> <span class="token punctuation">{</span> request<span class="token punctuation">.</span>session<span class="token punctuation">.</span>user_name <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>                  <span class="token operator">&lt;</span>li<span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"/logout/"</span><span class="token operator">></span>登出<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>              <span class="token punctuation">{</span> <span class="token operator">%</span> <span class="token keyword">else</span> <span class="token operator">%</span> <span class="token punctuation">}</span>                  <span class="token operator">&lt;</span>li<span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"/login/"</span><span class="token operator">></span>登录<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>                  <span class="token operator">&lt;</span>li<span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"/register/"</span><span class="token operator">></span>注册<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>              <span class="token punctuation">{</span> <span class="token operator">%</span> endif <span class="token operator">%</span> <span class="token punctuation">}</span>          <span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span>!<span class="token operator">-</span><span class="token operator">-</span> <span class="token operator">/</span><span class="token punctuation">.</span>navbar<span class="token operator">-</span>collapse <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span>!<span class="token operator">-</span><span class="token operator">-</span> <span class="token operator">/</span><span class="token punctuation">.</span>container<span class="token operator">-</span>fluid <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span></code></pre><p>通过if判断，当登录时，显示当前用户名和登出按钮。未登录时，显示登录和注册按钮。</p><p>注意其中的模板语言，<code>{ { request } }</code>这个变量会被默认传入模板中，可以通过圆点的调用方式，获取它内部的<code>{ { request.session } }</code>，再进一步的获取session中的内容。其实<code>{ { request } }</code>中的数据远不止此，例如<code>{ { request.path } }</code>就可以获取先前的url地址。</p><p>再修改一下<code>index.html</code>页面，根据登录与否的不同，显示不同的内容：</p><pre class=" language-python"><code class="language-python"><span class="token punctuation">{</span> <span class="token operator">%</span> extends <span class="token string">'base.html'</span> <span class="token operator">%</span> <span class="token punctuation">}</span><span class="token punctuation">{</span> <span class="token operator">%</span> block title <span class="token operator">%</span> <span class="token punctuation">}</span>主页<span class="token punctuation">{</span> <span class="token operator">%</span> endblock <span class="token operator">%</span> <span class="token punctuation">}</span><span class="token punctuation">{</span> <span class="token operator">%</span> block content <span class="token operator">%</span> <span class="token punctuation">}</span>    <span class="token punctuation">{</span> <span class="token operator">%</span> <span class="token keyword">if</span> request<span class="token punctuation">.</span>session<span class="token punctuation">.</span>is_login <span class="token operator">%</span> <span class="token punctuation">}</span>    <span class="token operator">&lt;</span>h1<span class="token operator">></span>你好<span class="token punctuation">,</span><span class="token punctuation">{</span> <span class="token punctuation">{</span> request<span class="token punctuation">.</span>session<span class="token punctuation">.</span>user_name <span class="token punctuation">}</span> <span class="token punctuation">}</span>！欢迎回来！<span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">></span>    <span class="token punctuation">{</span> <span class="token operator">%</span> <span class="token keyword">else</span> <span class="token operator">%</span> <span class="token punctuation">}</span>    <span class="token operator">&lt;</span>h1<span class="token operator">></span>你尚未登录，只能访问公开内容！<span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">></span>    <span class="token punctuation">{</span> <span class="token operator">%</span> endif <span class="token operator">%</span> <span class="token punctuation">}</span><span class="token punctuation">{</span> <span class="token operator">%</span> endblock <span class="token operator">%</span> <span class="token punctuation">}</span></code></pre><p><img src="https://gitee.com/sainthood2077/cloudimg/raw/main/images/image-20221023191150632.png" alt="效果"></p><h2 id="密码加密"><a href="#密码加密" class="headerlink" title="密码加密"></a>密码加密</h2><p>用户注册的密码应该加密才对</p><p>对于如何加密密码，有很多不同的途径，其安全程度也高低不等。这里我们使用Python内置的hashlib库，使用哈希值的方式加密密码，可能安全等级不够高，但足够简单，方便使用，不是么？</p><p>首先在<code>login/views.py</code>中编写一个hash函数：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> hashlib <span class="token keyword">def</span> <span class="token function">hash_code</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> salt<span class="token operator">=</span><span class="token string">'mysite'</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true"># 加点盐</span>    h <span class="token operator">=</span> hashlib<span class="token punctuation">.</span>sha256<span class="token punctuation">(</span><span class="token punctuation">)</span>    s <span class="token operator">+=</span> salt    h<span class="token punctuation">.</span>update<span class="token punctuation">(</span>s<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># update方法只接收bytes类型</span>    <span class="token keyword">return</span> h<span class="token punctuation">.</span>hexdigest<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>然后，我们还要对login()和register()视图进行一下修改：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#login.html</span> <span class="token keyword">if</span> user<span class="token punctuation">.</span>password <span class="token operator">==</span> hash_code<span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 哈希值和数据库内的值进行比对</span> <span class="token comment" spellcheck="true">#register.html</span> new_user<span class="token punctuation">.</span>password <span class="token operator">=</span> hash_code<span class="token punctuation">(</span>password1<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 使用加密密码</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># login/views.py</span> <span class="token keyword">from</span> django<span class="token punctuation">.</span>shortcuts <span class="token keyword">import</span> render<span class="token punctuation">,</span>redirect<span class="token keyword">from</span> <span class="token punctuation">.</span> <span class="token keyword">import</span> models<span class="token keyword">from</span> <span class="token punctuation">.</span>forms <span class="token keyword">import</span> UserForm<span class="token punctuation">,</span>RegisterForm<span class="token keyword">import</span> hashlib <span class="token keyword">def</span> <span class="token function">index</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span>    <span class="token keyword">return</span> render<span class="token punctuation">(</span>request<span class="token punctuation">,</span><span class="token string">'login/index.html'</span><span class="token punctuation">)</span> <span class="token keyword">def</span> <span class="token function">login</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> request<span class="token punctuation">.</span>session<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'is_login'</span><span class="token punctuation">,</span> None<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> redirect<span class="token punctuation">(</span><span class="token string">"/index/"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> request<span class="token punctuation">.</span>method <span class="token operator">==</span> <span class="token string">"POST"</span><span class="token punctuation">:</span>        login_form <span class="token operator">=</span> UserForm<span class="token punctuation">(</span>request<span class="token punctuation">.</span>POST<span class="token punctuation">)</span>        message <span class="token operator">=</span> <span class="token string">"请检查填写的内容！"</span>        <span class="token keyword">if</span> login_form<span class="token punctuation">.</span>is_valid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            username <span class="token operator">=</span> login_form<span class="token punctuation">.</span>cleaned_data<span class="token punctuation">[</span><span class="token string">'username'</span><span class="token punctuation">]</span>            password <span class="token operator">=</span> login_form<span class="token punctuation">.</span>cleaned_data<span class="token punctuation">[</span><span class="token string">'password'</span><span class="token punctuation">]</span>            <span class="token keyword">try</span><span class="token punctuation">:</span>                user <span class="token operator">=</span> models<span class="token punctuation">.</span>User<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>get<span class="token punctuation">(</span>name<span class="token operator">=</span>username<span class="token punctuation">)</span>                <span class="token keyword">if</span> user<span class="token punctuation">.</span>password <span class="token operator">==</span> hash_code<span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 哈希值和数据库内的值进行比对</span>                    request<span class="token punctuation">.</span>session<span class="token punctuation">[</span><span class="token string">'is_login'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>                    request<span class="token punctuation">.</span>session<span class="token punctuation">[</span><span class="token string">'user_id'</span><span class="token punctuation">]</span> <span class="token operator">=</span> user<span class="token punctuation">.</span>id                    request<span class="token punctuation">.</span>session<span class="token punctuation">[</span><span class="token string">'user_name'</span><span class="token punctuation">]</span> <span class="token operator">=</span> user<span class="token punctuation">.</span>name                    <span class="token keyword">return</span> redirect<span class="token punctuation">(</span><span class="token string">'/index/'</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    message <span class="token operator">=</span> <span class="token string">"密码不正确！"</span>            <span class="token keyword">except</span><span class="token punctuation">:</span>                message <span class="token operator">=</span> <span class="token string">"用户不存在！"</span>        <span class="token keyword">return</span> render<span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token string">'login/login.html'</span><span class="token punctuation">,</span> locals<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     login_form <span class="token operator">=</span> UserForm<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> render<span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token string">'login/login.html'</span><span class="token punctuation">,</span> locals<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">def</span> <span class="token function">register</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> request<span class="token punctuation">.</span>session<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'is_login'</span><span class="token punctuation">,</span> None<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 登录状态不允许注册。你可以修改这条原则！</span>        <span class="token keyword">return</span> redirect<span class="token punctuation">(</span><span class="token string">"/index/"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> request<span class="token punctuation">.</span>method <span class="token operator">==</span> <span class="token string">"POST"</span><span class="token punctuation">:</span>        register_form <span class="token operator">=</span> RegisterForm<span class="token punctuation">(</span>request<span class="token punctuation">.</span>POST<span class="token punctuation">)</span>        message <span class="token operator">=</span> <span class="token string">"请检查填写的内容！"</span>        <span class="token keyword">if</span> register_form<span class="token punctuation">.</span>is_valid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 获取数据</span>            username <span class="token operator">=</span> register_form<span class="token punctuation">.</span>cleaned_data<span class="token punctuation">[</span><span class="token string">'username'</span><span class="token punctuation">]</span>            password1 <span class="token operator">=</span> register_form<span class="token punctuation">.</span>cleaned_data<span class="token punctuation">[</span><span class="token string">'password1'</span><span class="token punctuation">]</span>            password2 <span class="token operator">=</span> register_form<span class="token punctuation">.</span>cleaned_data<span class="token punctuation">[</span><span class="token string">'password2'</span><span class="token punctuation">]</span>            email <span class="token operator">=</span> register_form<span class="token punctuation">.</span>cleaned_data<span class="token punctuation">[</span><span class="token string">'email'</span><span class="token punctuation">]</span>            sex <span class="token operator">=</span> register_form<span class="token punctuation">.</span>cleaned_data<span class="token punctuation">[</span><span class="token string">'sex'</span><span class="token punctuation">]</span>            <span class="token keyword">if</span> password1 <span class="token operator">!=</span> password2<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 判断两次密码是否相同</span>                message <span class="token operator">=</span> <span class="token string">"两次输入的密码不同！"</span>                <span class="token keyword">return</span> render<span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token string">'login/register.html'</span><span class="token punctuation">,</span> locals<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                same_name_user <span class="token operator">=</span> models<span class="token punctuation">.</span>User<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>filter<span class="token punctuation">(</span>name<span class="token operator">=</span>username<span class="token punctuation">)</span>                <span class="token keyword">if</span> same_name_user<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 用户名唯一</span>                    message <span class="token operator">=</span> <span class="token string">'用户已经存在，请重新选择用户名！'</span>                    <span class="token keyword">return</span> render<span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token string">'login/register.html'</span><span class="token punctuation">,</span> locals<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                same_email_user <span class="token operator">=</span> models<span class="token punctuation">.</span>User<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>filter<span class="token punctuation">(</span>email<span class="token operator">=</span>email<span class="token punctuation">)</span>                <span class="token keyword">if</span> same_email_user<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 邮箱地址唯一</span>                    message <span class="token operator">=</span> <span class="token string">'该邮箱地址已被注册，请使用别的邮箱！'</span>                    <span class="token keyword">return</span> render<span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token string">'login/register.html'</span><span class="token punctuation">,</span> locals<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                 <span class="token comment" spellcheck="true"># 当一切都OK的情况下，创建新用户</span>                 new_user <span class="token operator">=</span> models<span class="token punctuation">.</span>User<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>create<span class="token punctuation">(</span><span class="token punctuation">)</span>                new_user<span class="token punctuation">.</span>name <span class="token operator">=</span> username                new_user<span class="token punctuation">.</span>password <span class="token operator">=</span> hash_code<span class="token punctuation">(</span>password1<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 使用加密密码</span>                new_user<span class="token punctuation">.</span>email <span class="token operator">=</span> email                new_user<span class="token punctuation">.</span>sex <span class="token operator">=</span> sex                new_user<span class="token punctuation">.</span>save<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> redirect<span class="token punctuation">(</span><span class="token string">'/login/'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 自动跳转到登录页面</span>    register_form <span class="token operator">=</span> RegisterForm<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> render<span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token string">'login/register.html'</span><span class="token punctuation">,</span> locals<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">def</span> <span class="token function">logout</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token operator">not</span> request<span class="token punctuation">.</span>session<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'is_login'</span><span class="token punctuation">,</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> redirect<span class="token punctuation">(</span><span class="token string">'/index/'</span><span class="token punctuation">)</span>    request<span class="token punctuation">.</span>session<span class="token punctuation">.</span>flush<span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token keyword">return</span> redirect<span class="token punctuation">(</span><span class="token string">'/index/'</span><span class="token punctuation">)</span> <span class="token keyword">def</span> <span class="token function">hash_code</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> salt<span class="token operator">=</span><span class="token string">'mysite_login'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    h <span class="token operator">=</span> hashlib<span class="token punctuation">.</span>sha256<span class="token punctuation">(</span><span class="token punctuation">)</span>    s <span class="token operator">+=</span> salt    h<span class="token punctuation">.</span>update<span class="token punctuation">(</span>s<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># update方法只接收bytes类型</span>    <span class="token keyword">return</span> h<span class="token punctuation">.</span>hexdigest<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>重启服务器，进入注册页面，新建一个用户，然后进入admin后台，查看用户的密码情况：</p><p><img src="https://gitee.com/sainthood2077/cloudimg/raw/main/images/image-20221023191638938.png" alt="加密效果"></p><p> 再使用该用户登录一下，大功告成！</p><p>可以看到密码长度根据你哈希算法的不同，已经变得很长了，所以前面model中设置password字段时，不要想当然的将<code>max_length</code>设置为16这么小的数字。</p><h2 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h2><p>模板：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 以后可以随时更换title --></span>{ % block title % }{ % endblock % }<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 可以根据页面引入需要的css --></span>{ % block css % }{ % endblock % }<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    { % block content % }{ % endblock % }<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 可以根据页面引入需要的js --></span>{ % block js % }{ % endblock % }</code></pre><p>页面：</p><pre class=" language-html"><code class="language-html">{ % extends "模板名.html" % }{ % block title % }    添加用户{ % endblock % }{ % block css % }...{ % endblock % }{ % block content % }...{ % endblock % }{ % block js% }...{ % endblock % }</code></pre><h2 id="ModelForm组件-1"><a href="#ModelForm组件-1" class="headerlink" title="ModelForm组件"></a>ModelForm组件</h2><p>modelform： 针对数据库的某张表</p><p>form：登录</p><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><h2 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h2><p>highcharts：国外，开发时常用</p><p>echart：国内，初学时常用</p><p>通过ajax向后台获取数据</p><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><h3 id="混合数据"><a href="#混合数据" class="headerlink" title="混合数据"></a>混合数据</h3><p>form/modelfrom</p><p>有两个特殊的文件夹：</p><p><code>static</code>：项目文件css、js、项目图片</p><p><code>media</code>：用户上传的数据</p><p>启用media目录：</p><p>urls.py中加入</p><pre class=" language-python"><code class="language-python">urlpatterns <span class="token operator">=</span> <span class="token punctuation">[</span>    re_path<span class="token punctuation">(</span>r<span class="token string">'^media/(?P&lt;path>.*)$'</span><span class="token punctuation">,</span>serve<span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">'document_root'</span><span class="token punctuation">:</span>settings<span class="token punctuation">.</span>MEDIA_ROOT<span class="token punctuation">}</span><span class="token punctuation">,</span>name<span class="token operator">=</span><span class="token string">'media'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">]</span></code></pre><p>setting.py中加入</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> osMEDIA_ROOT <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>BASE_DIR<span class="token punctuation">,</span> <span class="token string">"media"</span><span class="token punctuation">)</span>MEDIA_URL <span class="token operator">=</span> <span class="token string">"/media/"</span></code></pre><p>位置就在根目录下</p><p><img src="https://gitee.com/sainthood2077/cloudimg/raw/main/images/image-20221118185255793.png" alt="image-20221118185255793"></p><h2 id="Bootstrap样式父类"><a href="#Bootstrap样式父类" class="headerlink" title="Bootstrap样式父类"></a>Bootstrap样式父类</h2><p><img src="https://gitee.com/sainthood2077/cloudimg/raw/main/images/image-20221113154717685.png" alt="image-20221113154717685"></p><p>views.py视图函数的拆分</p><h2 id="时间选择器插件"><a href="#时间选择器插件" class="headerlink" title="时间选择器插件"></a>时间选择器插件</h2><p>下载插件<a href="https://github.com/uxsolutions/bootstrap-datepicker">GitHub - uxsolutions/bootstrap-datepicker： a datepicker for twitter bootstrap （@twbs）</a></p><p>找到之中的dist取出改名为bootstrap-datepicker文件夹里就完成了，保存到项目的plugins里即可</p><p><img src="https://gitee.com/sainthood2077/cloudimg/raw/main/images/image-20221106093451058.png" alt="文件结构图"></p><p>在母版文件引入（在此之前需要同时引入bootstrap的css和js，和jquery）</p><pre class=" language-html"><code class="language-html">{ % block css% }&lt;link rel="stylesheet" href="{ % static "plugins/bootstrap-datepicker/css/bootstrap-datepicker.css" % }">{ % endblock % }<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dt<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>form-control<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>入职时间<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>{ % block js% }&lt;script src="{ % static "plugins/bootstrap-datepicker/js/bootstrap-datepicker.js" % }"><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>&lt;script src="{ % static "plugins/bootstrap-datepicker/locales/bootstrap-datepicker.zh-CN.min.js" % }"><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>{ % endblock % }<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">        <span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#dt'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">datepicker</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                format<span class="token punctuation">:</span> <span class="token string">'yyyy-mm-dd'</span><span class="token punctuation">,</span>                startDate<span class="token punctuation">:</span> <span class="token string">'0'</span><span class="token punctuation">,</span>                language<span class="token punctuation">:</span> <span class="token string">'zh-CN'</span><span class="token punctuation">,</span>                autoclose<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="form表单安全机制"><a href="#form表单安全机制" class="headerlink" title="form表单安全机制"></a>form表单安全机制</h3><p>只要有form表单就要先写一个{ % csrf_token % }，没有就会引起django安全机制报错，无法运行</p><h3 id="时间过滤器"><a href="#时间过滤器" class="headerlink" title="时间过滤器"></a>时间过滤器</h3><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>{ { obj.updatetime|date:"Y-m-d H:i:s” } }<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span></code></pre><h3 id="上线注意"><a href="#上线注意" class="headerlink" title="上线注意"></a>上线注意</h3><p>上线前要把所有引入的文件都改为.min.的版本</p><h2 id="学习总结"><a href="#学习总结" class="headerlink" title="学习总结"></a>学习总结</h2><ul><li>掌握django基础知识点后，练习一些项目案例</li><li>了解进阶的django知识点、组件，对原先每个模块的增删改查（复用率低，浪费资源）的代码优化</li><li>前后端分离项目 django + drf框架 + vue.js（现在企业常用的开发结构）</li><li>git版本控制和协同开发</li><li>微信小程序 + django + drf框架</li></ul><h2 id="学习DRF（Django-rest-framework）"><a href="#学习DRF（Django-rest-framework）" class="headerlink" title="学习DRF（Django-rest-framework）"></a>学习DRF（Django-rest-framework）</h2><blockquote><p>drf简介</p></blockquote><ul><li>提供了定义序列化器Serializer的方法，可以快速根据 Django ORM 或者其它库自动序列化/反序列化；</li><li>提供了丰富的类视图、Mixin扩展类，简化视图的编写；</li><li>丰富的定制层级：函数视图、类视图、视图集合到自动生成 API，满足各种需要；</li><li>多种身份认证和权限认证方式的支持；</li><li>内置了限流系统；</li><li>直观的 API web 界面；</li><li>可扩展性，插件丰富</li></ul><h3 id="1-安装DRF"><a href="#1-安装DRF" class="headerlink" title="1.安装DRF"></a>1.安装DRF</h3><pre class=" language-python"><code class="language-python">pip install djangorestframeworkpip install markdown       <span class="token comment" spellcheck="true"># Markdown support for the browsable API.</span>pip install django<span class="token operator">-</span>filter  <span class="token comment" spellcheck="true"># Filtering support</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手动添加Git到右键菜单</title>
      <link href="/2022/09/27/tian-jia-git-bash-here/"/>
      <url>/2022/09/27/tian-jia-git-bash-here/</url>
      
        <content type="html"><![CDATA[<p>由于不知原因，右键没有了Git Bash Here，没有这个右键菜单导致获取Git仓库中的代码很不方便，所以决定通过注册表的方式将这个菜单加出来。</p><p>1、win + R，输入“regedit”，回车打开注册表；</p><p>2、找到 [HKEY_CLASSES_ROOT\Directory\Background]；</p><p>3、在 [Background] 下如果没有 [shell]，则右键-新建项 [shell]；</p><p>4、在 [shell] 下右键-新建项[Git Bash Here]，此为右键菜单显示名称；</p><p>5、在 [Git Bash Here] 下右键-新建-字符串值[Icon],双击编辑，其值为“D:\Git\mingw64\share\git\git-for-windows.ico”。此为菜单加图标，“D:\Git”为安装路径。</p><p>6、在 [Git Bash Here] 下右键-新建-项[command],其值为 “D:\Git\git-bash.exe”。</p><p>然后就能在鼠标右键（win11要打开更多选项）就有显示</p><p>原创链接：<a href="https://www.cnblogs.com/rnckty/p/7607445.html">手动添加 Git bash 到鼠标右键 - 贱书生 - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
          <category> 右键菜单 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
